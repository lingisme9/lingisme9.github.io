<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python描述的数据结构</title>
      <link href="/2020/092322154.html"/>
      <url>/2020/092322154.html</url>
      
        <content type="html"><![CDATA[<h1 id="python数据结构"><a href="#python数据结构" class="headerlink" title="python数据结构"></a>python数据结构</h1><p>1.<a href="http://9fdf7a.coding-pages.com/index.html" target="_blank" rel="noopener">python数据结构</a></p><p><a href="https://imgchr.com/i/wjNoJ1" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/23/wjNoJ1.png" alt="wjNoJ1.png"></a></p><p><strong>绪论需要关注的：</strong></p><p>2.<a href="https://www.bilibili.com/video/BV1e4411s7Kw?p=2" target="_blank" rel="noopener">时间复杂度大O记法视频</a></p><p>3.<a href="https://www.bilibili.com/video/BV1e4411s7Kw?p=3" target="_blank" rel="noopener">最坏时间复杂度与计算规则</a></p><p>4.<a href="https://www.bilibili.com/video/BV1e4411s7Kw?p=4" target="_blank" rel="noopener">常见时间复杂度与大小关系</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法总结</title>
      <link href="/2020/092257899.html"/>
      <url>/2020/092257899.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="第一章-算法基础"><a href="#第一章-算法基础" class="headerlink" title="第一章 算法基础"></a>第一章 算法基础</h2><p><img src="https://s1.ax1x.com/2020/09/22/wXQEYF.png" alt="wXQEYF.png"></p><p><img src="https://s1.ax1x.com/2020/09/22/wXQYSH.png" alt="wXQYSH.png"></p><p><img src="https://s1.ax1x.com/2020/09/22/wXQ0Tf.png" alt="wXQ0Tf.png"></p><p><img src="https://s1.ax1x.com/2020/09/22/wXQg6s.png" alt="wXQg6s.png"></p><p><img src="https://s1.ax1x.com/2020/09/22/wXQItU.png" alt="wXQItU.png"></p><pre><code>一、选择题1、衡量一个算法好坏的标准是（C ）。A 运行速度快   B 占用空间少   C 时间复杂度低   D 代码短</code></pre><pre><code>1、什么是算法？算法的特征有哪些？答：1）算法：指在解决问题时，按照某种机械步骤一定可以得到问题结果的处理过程。通俗讲，算法：就是解决问题的方法或过程。2）特征：1)算法有零个或多个输入；２)算法有一个或多个输出； 3)确定性 ； ４)有穷性</code></pre><pre><code>2、算法分析的目的？答：1)为了对算法的某些特定输入，估算该算法所需的内存空间和运行时间；2)是为了建立衡量算法优劣的标准，用以比较同一类问题的不同算法。</code></pre><pre><code>3、算法设计常用的技术？（写4-５种）  答： ①分治法;  ②回溯法；      ③贪心法；     ④动态规划法    ⑤分治限界法 ； ⑥蛮力法； </code></pre><pre><code>2、给出算法的定义？何谓算法的复杂性？计算下例在最坏情况下的时间复杂性？for(j=1;j&lt;=n;j++)                        (1)for(i=1;i&lt;=n;i++)                         (2)                                           {c[i][j]=0;                           (3)                            for(k=1;k&lt;=n;k++)                   (4)                     c[i][j]= c[i][j]+a[i][k]*b[k][j];         }  (5)答：1）定义：指在解决问题时，按照某种机械步骤一定可以得到问题结果的处理过程。     2）算法的复杂性：指的是算法在运行过程中所需要的资源（时间、空间）多少。    所需资源越多，表明算法的复杂性越高    3）该算法的主要元操作是语句5，其执行次数是n3次。    故该算法的时间复杂度记为O(n3). </code></pre><pre><code>#include&lt;stdio.h&gt;int main(){    int k = 0;    printf("输入一个正整数2的次方:");    int n;    scanf("%d",&amp;n);    while(n &gt;= 1)    {        for(int j=1;j&lt;=n;j++)        {                k = k + 1;                printf("%d",k);        }        n = n/2;        }     return 0;}</code></pre><h2 id="第二章-分治算法"><a href="#第二章-分治算法" class="headerlink" title="第二章 分治算法"></a>第二章 分治算法</h2><h3 id="0-0-题目"><a href="#0-0-题目" class="headerlink" title="0.0 题目"></a>0.0 题目</h3><pre><code>1、二分搜索算法是利用（   A  ）实现的算法。A、分治策略   B、动态规划法   C、贪心法    D、回溯法2. 实现循环赛日程表利用的算法是（    A      ）。A、分治策略            B、动态规划法            C、贪心法            D、回溯法</code></pre><pre><code>1、什么是递归算法？递归算法的特点？答：1 )递归算法:是一个模块（函数、过程）除了可调用其它模块（函数、过程）外，还可以直接或间接地调用自身的算法。2) 递归算法特点：①每个递归函数都必须有非递归定义的初值；否则，递归函数无法计算；（递归终止条件）②递归中用较小自变量函数值来表达较大自变量函数值；（递归方程式）</code></pre><pre><code>2、比较循环与递归的异同？答：1)    相同：递归与循环都是解决“重复操作”的机制。2)    不同：就效率而言，递归算法的实现往往要比迭代算法耗费更多的时间（调用和返回均需要额外的时间）与存贮空间（用来保存不同次调用情况下变量的当前值的栈栈空间），也限制了递归的深度。每个迭代算法原则上总可以转换成与它等价的递归算法；反之不然 。递归的层次是可以控制的，而循环嵌套的层次只能是固定的，因此递归是比循环更灵活的重复操作的机制。</code></pre><pre><code>3、适合用分治算法求解的问题具有的基本特征？答：1)该问题的规模缩小到一定的程度就可以容易解决;2)该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；3）该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 4）利用该问题分解出子问题解可以合并为该问题解;</code></pre><pre><code>四、算法设计题：（大题）课后习题2.5,2.91、楼梯上有n个台阶，上楼时可以上1步，也可以上2步，设计一递归算法求出共有多少种上楼方法F(n)。①写出F(n)的递归表达式        ②并写出其相应的递归算法③并分析其算法复杂度解：①写出F(n)的递归表达式分析：到n阶有两种走法：                   1）n-1阶到n阶；                   2）n-2阶到n阶；            1                           n=1            F(n) ＝    2                           n=2            F(n-1) + F(n-2)     n&gt;2②写出其相应的递归算法？Int F(int n){   if(n=1)    return   1;   else if(n=2)        return   2;   else      return  F(n-1)+ F(n-2);}2、改写二分查找算法：设a[1…n]是一个已经排好序的数组，改写二分查找算法，使得当搜索元素x不在数组中时，返回小于x的最大元素位置i，和大于x的最小元素位置j；当搜索元素x在数组中时，i和j相同，均为x在数组中的位置。    并分析其时间复杂度？        解：int  binsearch( int a[n],  int  x ,)     //x待查数据    {int  mid, i ,  j;          low=1;     int  high=n;    while(low&lt;=high)        {mid=(low+high)/2;        if(a[mid]=x)     return  i=j=mid;        if(a[mid]&gt;x)    high=mid-1;       //继续在左边查找        else                                // (a[mid]&lt;x)             low=mid+1;        //继续在右边查找          }         i=right;    j=left;       return   0；//low大于high查找区间为空，查找失败    }计算时间复杂性为O(logn)</code></pre><h3 id="0-基本思想"><a href="#0-基本思想" class="headerlink" title="0.基本思想"></a>0.基本思想</h3><h3 id="1-合并排序"><a href="#1-合并排序" class="headerlink" title="1.合并排序"></a>1.合并排序</h3><h4 id="1-0-合并排序"><a href="#1-0-合并排序" class="headerlink" title="1.0 合并排序"></a>1.0 合并排序</h4><p><img src="https://s1.ax1x.com/2020/09/22/wXlyE6.png" alt="wXlyE6.png"></p><h4 id="1-0-1-时间复杂度"><a href="#1-0-1-时间复杂度" class="headerlink" title="1.0.1 时间复杂度"></a>1.0.1 时间复杂度</h4><p><img src="https://s1.ax1x.com/2020/09/22/wXlR8e.png" alt="wXlR8e.png"></p><h4 id="1-1-合并排序与快速排序的比较："><a href="#1-1-合并排序与快速排序的比较：" class="headerlink" title="1.1 合并排序与快速排序的比较："></a>1.1 <strong>合并排序与快速排序的比较</strong>：</h4><pre><code>四．合并排序与快速排序的比较：1.分解过程：合并排序：将序列一分为二即可（简单）快速排序：需调用Paitition函数将一个序列划分为子序列。（分解方法相对较困难）2.子问题解合并得到原问题解的过程：合并排序——需要调用Merge函数（时间复杂度为O（n））来实现。快速排序——一旦左右两个子序列都已分别排序，整个序列便自然成为有序序列。（异常简单，几乎无须额外的工作，省去了从子问题解合并得到原问题解的过程）3.掌握合并排序和快速排序的具体排序方法（数据结构内容）。（图5-2，图5-4快速排序的划分操作）</code></pre><pre><code>非递归方式合并排序/二路归并排序/归并排序方法：1 先分解成两个数组2 分别给两个数组排序3 合并两个排好序得数组</code></pre><pre class=" language-C"><code class="language-C">#include <malloc.h>#include <stdlib.h>#include<stdio.h>//合并排序的递归主体void mergesort(int A[],int n)  {    //声明merge函数    // A 整个数组  L 左边数组  R 右边数组      // 将排好序得两个数组比较好后放入新数组     //     void merge(int A[], int L[], int R[], int l, int r);     //多于一个元素才需要排序     if(n>1)        {        int mid=n/2;        int *left=(int*)malloc(sizeof(int)*mid);        int *right=(int*)malloc(sizeof(int)*(n-mid));        // 0-mid         // 1 2 3 4 5 6 7         for(int i=0;i<mid;i++)            //建立临时数组存储左半部分序列            left[i]=A[i];         // mid-n-1              for(int j=mid;j<n;j++)            //建立临时数组存储右半部分序列            // 3 4 5 6 7            // 0 1 2 3 4             right[j-mid]=A[j];          //调用自身对左半部分进行合并排序        mergesort(left,mid);        //调用自身对右半部分进行合并排序            mergesort(right,n-mid);        //两个有序序列的合并操作，封装为函数         merge(A,left,right,mid,n-mid);           free(left);        free(right);    }}//两个有序序列L、R合并为A，l,r分别为L,R的长度void merge(int A[],int L[],int R[],int l,int r)  {    int i=0,j=0,k=0;    //两个子序列首元素做比较，小者取出置入父序列    while(i<l&&j<r)      {        if(L[i]<=R[j])            A[k++]=L[i++];        else            A[k++]=R[j++];    }    //将左半部分剩余元素置入父序列    while(i<l)           {        A[k++]=L[i++];    }    //将右半部分剩余元素置入父序列    while(j<r)           {        A[k++]=R[j++];    }}int main(){    int n = 5;    int a[100] = {1,3,2,5,4};    mergesort(a,n);    for(int i = 0; i < n; i++)        printf("%d ",a[i]);    return 0;} </code></pre><h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h3><p><img src="https://s1.ax1x.com/2020/09/22/wXl7Uf.png" alt="wXl7Uf.png"></p><p>它是一种稳定的排序方法。快速排序利用分治思想，将待排序数组分成左右两个部分，然后对其分别递归调用快速排序算法</p><h4 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h4><p><img src="https://s1.ax1x.com/2020/09/22/wXlXvj.png" alt="wXlXvj.png"><br><img src="https://s1.ax1x.com/2020/09/22/wX1UdP.png" alt="wX1UdP.png"><br><img src="https://s1.ax1x.com/2020/09/22/wX3iwt.png" alt="wX3iwt.png"></p><h4 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程"></a>2.流程</h4><p>快速排序算法通过多次比较和交换来实现排序，其排序流程如下： [2] </p><p>(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 [2] </p><p>(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。 [2] </p><p>(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 [2] </p><p>(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。 [2]</p><h4 id="3-例子"><a href="#3-例子" class="headerlink" title="3.例子"></a>3.例子</h4><pre><code>下面通过一个例子介绍快速排序算法的思想，假设要对数组a[10]={6，1，2，7，9，3，4，5，10，8}进行排序，首先要在数组中选择一个数作为基准值，这个数可以随意选择，在这里，我们选择数组的第一个元素a[0]=6作为基准值，接下来，我们需要把数组中小于6的数放在左边，大于6的数放在右边</code></pre><p>我们设置两个“哨兵”，记为“哨兵i”和“哨兵j”，他们分别指向数组的第一个元素和最后一个元素，即i=0，j=9。首先哨兵j开始出动，哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。</p><p>最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。此时就需要交换i和j指向的元素的值。</p><p><img src="https://s1.ax1x.com/2020/09/22/wX3mlQ.png" alt="wX3mlQ.png"></p><p>交换之后的数组变为a[10]={6，1，2，5，9，3，4，7，10，8}：</p><p>第一次交换至此结束。接下来，由于哨兵i和哨兵j还没有相遇，于是哨兵j继续向前，发现比6小的4之后停下；哨兵i继续向前，发现比6大的9之后停下，两者再进行交换。交换之后的数组变为a[10]={6，1，2，5，4，3，9，7，10，8}。</p><p><img src="https://s1.ax1x.com/2020/09/22/wX3nyj.png" alt="wX3nyj.png"></p><p>第二次交换至此结束。接下来，哨兵j继续向前，发小比6小的3停下来；哨兵i继续向前，发现i==j了！！！于是，这一轮的探测就要结束了，此时交换a[i]与基准的值，数组a就以6为分界线，分成了小于6和大于6的左右两部分：a[10]={3，1，2，5，4，6，9，7，10，8}。</p><p><img src="https://s1.ax1x.com/2020/09/22/wX3Qwq.png" alt="wX3Qwq.png"><br><img src="https://s1.ax1x.com/2020/09/22/wX38YT.png" alt="wX38YT.png"></p><p>至此，第一轮快速排序完全结束，接下来，对于6左边的半部分3，1，2，5，4，执行以上过程；对于6右边的半部分9，7，10，8，执行以上过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列：1 2 3 4 5 6 7 8 9 10，到此，排序完全结束。</p><pre><code>算法思路    1 选择基准线    2 右边选择一个比基准线小的    3 左边选择一个比基准线大的    4 交换两个数    5 i=j时，基准线和ai交换</code></pre><p><strong>时间复杂度</strong></p><p><img src="https://s1.ax1x.com/2020/09/22/wX3N6J.png" alt="wX3N6J.png"></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token comment" spellcheck="true">//定义全局变量，这两个变量需要在子函数中使用</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">,</span>n<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">quicksort</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> t<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//temp中存的就是基准数</span>    i <span class="token operator">=</span> left<span class="token punctuation">;</span>    j <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//顺序很重要，要先从右边开始找</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> temp <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//再找右边的</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//交换两个数在数组中的位置</span>        <span class="token punctuation">{</span>            t <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//最后i=j时，ai和基准交换 </span>    a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token function">quicksort</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//继续处理左边的，这里是一个递归的过程</span>    <span class="token function">quicksort</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//继续处理右边的 ，这里是一个递归的过程</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//读入数据</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入数组元素个数："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入数组元素%d个"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quicksort</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//快速排序调用</span>    <span class="token comment" spellcheck="true">//输出排序后的结果</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-二分查找-有序"><a href="#3-二分查找-有序" class="headerlink" title="3.二分查找(有序)"></a>3.二分查找(有序)</h3><p>​        二分査找就是折半查找，其基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）。</p><p>为了方便理解，我们以数组<code>1, 2, 4, 5, 6, 7, 9, 12, 15, 19, 23, 26, 29, 34, 39</code>，在数组中查找<code>26</code>为例，制作了一张查找过程图，其中<code>low</code>标示左下标，<code>high</code>标示右下标，<code>mid</code>标示中间值下标</p><p><img src="https://s1.ax1x.com/2020/09/22/wX3f0I.png" alt="wX3f0I.png"></p><pre><code>#include &lt;stdio.h&gt;int binary_search(int key,int a[],int n) //自定义函数binary_search(){    int low,high,mid,count=0,count1=0;    low=0;    high=n-1;    while(low&lt;high)    //査找范围不为0时执行循环体语句    {        count++;    //count记录査找次数        mid=(low+high)/2;    //求中间位置        if(key&lt;a[mid])    //key小于中间值时            high=mid-1;    //确定左子表范围        else if(key&gt;a[mid])    //key 大于中间值时            low=mid+1;    //确定右子表范围        else if(key==a[mid])    //当key等于中间值时，证明查找成功        {            printf("查找成功!\n 查找 %d 次!a[%d]=%d",count,mid,key);    //输出査找次数及所査找元素在数组中的位置            count1++;    //count1记录查找成功次数            break;        }    }    if(count1==0)    //判断是否查找失敗        printf("查找失敗!");    //査找失敗输出no found    return 0;}int main(){    int i,key,a[100],n;    printf("请输入数组的长度：\n");    scanf("%d",&amp;n);    //输入数组元素个数    printf("请输入数组元素：\n");    for(i=0;i&lt;n;i++)        scanf("%d",&amp;a[i]);    //输入有序数列到数组a中    printf("请输入你想查找的元素：\n");    scanf("%d",&amp;key);    //输入要^找的关键字    binary_search(key,a,n);    //调用自定义函数    printf("\n");    return 0;}</code></pre><h4 id="3-时间复杂度"><a href="#3-时间复杂度" class="headerlink" title="3.时间复杂度"></a>3.时间复杂度</h4><p><img src="https://s1.ax1x.com/2020/09/22/wX3bcQ.png" alt="wX3bcQ.png"></p><h3 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.冒泡排序"></a>4.冒泡排序</h3><p>冒泡排序分<strong>从大到小</strong>和<strong>从小到大</strong>两种排序方式。它们的唯一区别就是两个数交换的条件不同，从大到小排序是前面的数比后面的小的时候交换，而从小到大排序是前面的数比后面的数大的时候交换。我这里只说 从小到大的排序方式。</p><p><strong>冒泡排序的原理</strong>：从第一个数开始，依次往后比较，如果前面的数比后面的数大就<strong>交换</strong>，否则不作处理。这就类似烧开水时，壶底的水泡往上冒的过程。</p><p>现以数组[8,7,6,4,5]为例，我们通过将这个数组按<strong>从小到大</strong>的方式排序，来说明冒泡排序的过程。</p><p><strong>第一次循环</strong>：此次循环的多次比较交换，使最大的数字8冒到最上面。</p><p><img src="https://s1.ax1x.com/2020/09/22/wX3Ons.png" alt="wX3Ons.png"><br><img src="https://s1.ax1x.com/2020/09/22/wX3j7q.png" alt="wX3j7q.png"><br>你会发现，这次循环比前面少一次循环比较。</p><p>这是因为第一次循环时已经把最大的8排到最上面的位置了，这次排序肯定不会去占用最上面的位置的，所以此时比较次数可以比前面少一次。</p><p><strong>第三次循环</strong>：同理，此时6会往上冒。比较次数同理又会比前面少一次</p><p><img src="https://s1.ax1x.com/2020/09/22/wX8Pc4.png" alt="wX8Pc4.png"></p><p>此时看着最后的结果已经是从小到大了，这是因为在原始数组中，5就在4的上面。</p><p>但实际我们不知道5是在4的上面，我们就得继续完成最后一次循环比较。</p><p><strong>第四次循环</strong>： 5已经排在4的上面了，比较后不交换。</p><p><img src="https://s1.ax1x.com/2020/09/22/wX8EH1.png" alt="wX8EH1.png"></p><pre><code>#include&lt;stdio.h&gt;int main(void){    int a[10],n=5;    int i,j,m;    for(i=0;i&lt;n;i++){        scanf("%d",&amp;a[i]);    }    for(i=n-1;i&gt;0;i--){        for(j=0;j&lt;i;j++){            if(a[j]&lt;a[j+1]){                m=a[j+1];                a[j+1]=a[j];                a[j]=m;            }        }    }    for(i=0;i&lt;5;i++){        printf("%d ",a[i]);    }    printf("\n");    return 0;}//从大到小</code></pre><h4 id="3-时间复杂度-1"><a href="#3-时间复杂度-1" class="headerlink" title="3.时间复杂度"></a>3.时间复杂度</h4><p><img src="https://s1.ax1x.com/2020/09/22/wX81ud.png" alt="wX81ud.png"></p><h3 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5.选择排序"></a>5.选择排序</h3><p>选择排序法<br>选择排序法的主要思想是将一组数（n个）中的最大值（或最小值）先挑出来，放在首（或尾），然后在剩下的n-1个数中再次挑出最大值（或最小值），放在前一个最大值（或最小值）的前面（或后面），以此类推。所以安排两层循环，一层固定一个数的时候，另一层逐次比较。</p><pre><code>#include&lt;stdio.h&gt;int main(void){    int a[10],n=10;    int i,j,m;    for(i=0;i&lt;n;i++){        scanf("%d",&amp;a[i]);    }    for(i=0;i&lt;n;i++){        for(j=i+1;j&lt;n;j++){            if(a[i]&gt;a[j]){                m=a[i];//注意，此处的位置对调需要中间变量来辅助                 a[i]=a[j];                a[j]=m;            }        }    }    for(i=0;i&lt;10;i++){        printf("%d ",a[i]);    }    printf("\n");    return 0;} //从小到大</code></pre><p> -1)次<br>综合起来，直接选择排序的时间复杂度也是O(n^2)                                                                                                                                                                                                                                    </p><h2 id="第三章-动态规划"><a href="#第三章-动态规划" class="headerlink" title="第三章 动态规划"></a>第三章 动态规划</h2><h3 id="0-题目"><a href="#0-题目" class="headerlink" title="0.题目"></a>0.题目</h3><p><strong>名词解释：</strong></p><p>最优解：使<a href="https://baike.baidu.com/item/目标函数" target="_blank" rel="noopener">目标函数</a>取最小值或最大值的可行解</p><p>优化原则：</p><p>1： 在能应付当前性能需求的情况下，不建议进行性能优化。</p><p>2： 仅仅优化性能瓶颈</p><p>3： 编码时必须进行压力测试</p><p>4： 优化时，考虑现实生活中遇到的问题，现实如何处理，代码也如何处理。</p><p>5： 优化的唯一方法：去掉没有必要的操作 和 采取高效的算法。可以看到所有的优化方法都离不开这条原则，而最常用、也最容易发现的方案就是去掉没必要的操作。</p><p>最优子结构：1．<strong>最优子结构特性</strong>：一个问题的最优解包含其子问题的最优解；</p><p>线性规划：研究线性<a href="https://baike.baidu.com/item/约束条件/1046571" target="_blank" rel="noopener">约束条件</a>下线性目标函数的<a href="https://baike.baidu.com/item/极值/5330918" target="_blank" rel="noopener">极值</a>问题的方法</p><p>整数规划：整数规划是指规划中的变量（全部或部分）限制为<a href="https://baike.baidu.com/item/整数/1293937" target="_blank" rel="noopener">整数</a>，若在线性模型中，变量限制为整数，则称为整数线性规划</p><p>0-1背包：<strong>0/1背包问题</strong>：如果每一件物品不能分割，只能作为整体或者装入背包，或者不装入；</p><p>公共子序列：一个给定序列的子序列是在该序列中删去若干元素后得到的序列</p><p><strong>重叠子问题</strong>：递归算法求解问题时，每次产生的子问题并不总是新问题，有些问题被反复计算多次。</p><pre><code>1、下列不是动态规划算法基本步骤的是（  A   ）。A、找出最优解的性质   B、构造最优解   C、算出最优解   D、定义最优解2．最长公共子序列算法利用的算法是（    B       ）。A、分支界限法        B、动态规划法            C、贪心法                D、回溯法</code></pre><pre><code>1、动态规划算法基本思想？答：　动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。2、动态规划与分治算法异同点？动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题；但是经分解得到的子问题往往不是互相独立的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次；如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。3、动态规划算法的基本要素？   最优子结构当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。在动态规划算法中，利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。重叠子问题可用动态规划算法求解的问题应具备的另一个基本要素是子问题的重叠性质。在用递归算法自顶向下求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要此子问题时，只要简单地用常数时间查看一下结果。通常，不同的子问题个数随问题的大小呈多项式增长。因此，用动态规划算法通常只需要多项式时间，从而获得较高的解题效率。备忘录方法就可以在递归处理问题的基础上，将需要后来多次计算的问题进行缓存，减少了重复子问题的计算。但是书中所记的备忘录方法没有真正的将自上而下的精髓体现出来，若是将自上而下的思想结合最优子结构的思想，则可以对问题进行修剪枝条，在宏观出即可去掉一大部分的不需计算的方面，比如一个问题的划分可以有两种，选择了最优的一种，就可以将另一种非最优情况下的所有计算均省去，然后再对第一次的划分再次进行划分，其结构是树由根向叶，不断的择取最优的树干，最终至叶子，非最优树干直接不计算。</code></pre><pre><code>四、算法设计题（大题）：课后题3.4 3.61、用动态规划策略求解最长公共子序列问题：（1）给出计算最优值的递归方程。（2）给定两个序列 X={B,C,D,A} ，Y={A,B,C,B} ，请采用动态规划策略求出其最长公共子序列，要求给出过程。</code></pre><p><img src="https://s1.ax1x.com/2020/09/22/wX8fv4.png" alt="wX8fv4.png"></p><h3 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h3><p><img src="https://s1.ax1x.com/2020/09/22/wX8TV1.png" alt="wX8TV1.png"></p><p>二．<strong>动态规划法的基本要素</strong>：</p><p>1．<strong>最优子结构特性</strong>：一个问题的最优解包含其子问题的最优解；</p><p>1．<strong>重叠子问题</strong>：递归算法求解问题时，每次产生的子问题并不总是新问题，有些问题被反复计算多次。</p><p>三．<strong>动态规划法与分治法的比较</strong>：</p><p><strong>共同点</strong>：将待求解的问题分解成若干个子问题，先求子问题，然后再从这些子问题的解得到原问题的解；</p><p><strong>不同点</strong>：1.适合于用动态规划法求解的问题，分解得到的各子问题往往<strong>不是相互独立</strong>的；而分治法中的子问题是相互独立的；</p><p>2.动态规划法<strong>用表</strong>保存已求解过的子问题的解，再次碰到同样的子问题时不必重新求解，而只需查询答案，<strong>故可获得多项式级时间复杂度</strong>，效率较高；而分治法中对于每次出现的子问均求解，导致同样的子问题被反复求解，故产生指数增长的时间复杂度，效率较低。</p><p>四．<strong>动态规划法与贪心法的比较</strong>：</p><p><strong>共同点</strong>：都是求解最优化问题；都要求问题具有最优子结构性质；</p><p><strong>不同点</strong>：</p><p>1.<strong>求解方式</strong>不同：</p><p>动态规划法是：<strong>自底向上</strong>；</p><p>贪心法是：<strong>自顶向下</strong>；以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为一个规模更小的子问题；</p><p>2.<strong>对子问题的依赖不同</strong>：</p><p>动态规划法：依赖各子问题的解，所以只有在解出相关子问题后，才能作出选择；应使各子问题最优，才能保证整体最优；</p><p>贪心法：不依赖于子问题的解；仅在当前状态下作出最好选择，即局部最优选择，然后再去解作出这个选择后产生的相应的子问题。</p><p>五．<strong>两类背包问题</strong>：</p><p>1.<strong>0/1背包问题</strong>：如果每一件物品不能分割，只能作为整体或者装入背包，或者不装入；</p><p>2.<strong>一般背包问题或简称背包问题</strong>：如果物品时可以分割的，也就是允许将其中的一部分装入背包。</p><p><strong>六．动态规划法的典型应用：多段图问题</strong></p><p>多段图问题是求从源点s到汇点t的一条长度最短的路径（用从后逐步向前递推的方法）</p><h3 id="3、动态规划算法的基本要素？"><a href="#3、动态规划算法的基本要素？" class="headerlink" title="3、动态规划算法的基本要素？"></a>3、动态规划算法的基本要素？</h3><p>最优子结构</p><p>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。</p><p>在动态规划算法中，利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。</p><p>重叠子问题</p><p>可用动态规划算法求解的问题应具备的另一个基本要素是子问题的重叠性质。在用递归算法自顶向下求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要此子问题时，只要简单地用常数时间查看一下结果。通常，不同的子问题个数随问题的大小呈多项式增长。因此，用动态规划算法通常只需要多项式时间，从而获得较高的解题效率。</p><p>备忘录方法</p><p>就可以在递归处理问题的基础上，将需要后来多次计算的问题进行缓存，减少了重复子问题的计算。但是书中所记的备忘录方法没有真正的将自上而下的精髓体现出来，若是将自上而下的思想结合最优子结构的思想，则可以对问题进行修剪枝条，在宏观出即可去掉一大部分的不需计算的方面，比如一个问题的划分可以有两种，选择了最优的一种，就可以将另一种非最优情况下的所有计算均省去，然后再对第一次的划分再次进行划分，其结构是树由根向叶，不断的择取最优的树干，最终至叶子，非最优树干直接不计算。</p><h3 id="4-最长公共子序列"><a href="#4-最长公共子序列" class="headerlink" title="4.最长公共子序列"></a>4.最长公共子序列</h3><p><img src="https://s1.ax1x.com/2020/09/22/wX8qPK.png" alt="wX8qPK.png"></p><h4 id="1-什么是子序列"><a href="#1-什么是子序列" class="headerlink" title="1.什么是子序列"></a>1.什么是子序列</h4><p>在数学中，某个序列的<strong>子序列</strong>是从最初序列通过去除某些元素但不破坏余下元素的相对位置（在前或在后）而形成的新序列。详情请查看<a href="https://links.jianshu.com/go?to=%5Bhttps%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E5%AD%90%E5%BA%8F%E5%88%97%5D(https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E5%AD%90%E5%BA%8F%E5%88%97)" target="_blank" rel="noopener">wike百科</a>。<br> 举个例子：[a,b,c,d,e]，如果找一个子序列，可以是[a,b,c],[a,c,e],[b,e],但不可以是[c,a,e],这个例子举得比较特殊，下标越大，字母越靠后，而如果原本下标比较小得字母排到下标大的后面，这就不符合子序列的定义了。</p><h4 id="2-什么是最长公共子序列"><a href="#2-什么是最长公共子序列" class="headerlink" title="2.什么是最长公共子序列"></a>2.什么是最长公共子序列</h4><p>这个不需要多说，如果是求数组A和B的最长公共子序列，就是说既是A的子序列又是B的子序列，而且要保证最长。</p><pre><code>1、用动态规划策略求解最长公共子序列问题：（1）给出计算最优值的递归方程。（2）给定两个序列 X={B,C,D,A} ，Y={A,B,C,B} ，请采用动态规划策略求出其最长公共子序列，要求给出过程。</code></pre><p><strong>相等为前一个的最大+1，不相等，左上最大取，倒回去</strong></p><p> <img src="https://s1.ax1x.com/2020/09/22/wX8Xxe.png" alt="wX8Xxe.png"></p><h4 id="3-特征分析"><a href="#3-特征分析" class="headerlink" title="3.特征分析"></a>3.特征分析</h4><p>​    解决LCS问题，需要把原问题分解成若干个子问题，所以需要刻画LCS的特征。</p><p>​    设A=“a0，a1，…，am”，B=“b0，b1，…，bn”，且Z=“z0，z1，…，zk”为它们的最长公共子序列。不难证明有以下性质：</p><p>​    如果am=bn，则zk=am=bn，且“z0，z1，…，z(k-1)”是“a0，a1，…，a(m-1)”和“b0，b1，…，b(n-1)”的一个最长公共子序列；</p><p>​    如果am!=bn，则若zk!=am，蕴涵“z0，z1，…，zk”是“a0，a1，…，a(m-1)”和“b0，b1，…，bn”的一个最长公共子序列；</p><p>​    如果am!=bn，则若zk!=bn，蕴涵“z0，z1，…，zk”是“a0，a1，…，am”和“b0，b1，…，b(n-1)”的一个最长公共子序列。</p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200901165003604.png" alt="image-20200901165003604"></p><p>以我在第1小节举的例子（S1={1,3,4,5,6,7,7,8}和S2={3,5,7,4,8,6,7,8,2}），并结合上图来说：</p><p>​    假如S1的最后一个元素 与 S2的最后一个元素相等，那么S1和S2的LCS就等于 {S1减去最后一个元素} 与 {S2减去最后一个元素} 的 LCS  再加上 S1和S2相等的最后一个元素。</p><p>​    假如S1的最后一个元素 与 S2的最后一个元素不等（本例子就是属于这种情况），那么S1和S2的LCS就等于 ： {S1减去最后一个元素} 与 S2 的LCS， {S2减去最后一个元素} 与 S1 的LCS 中的最大的那个序列。</p><h4 id="4-递归公式"><a href="#4-递归公式" class="headerlink" title="4.递归公式"></a>4.递归公式</h4><p>​    第3节说了LCS的特征，我们可以发现，假设我需要求 a1 … am 和 b1 .. b(n-1)的LCS 和 a1 … a(m-1) 和 b1 .. bn的LCS，一定会递归地并且重复地把如a1… a(m-1) 与 b1 … b(n-1) 的 LCS 计算几次。所以我们需要一个数据结构来记录中间结果，避免重复计算。</p><p>​    假设我们用c[i,j]表示Xi 和 Yj 的LCS的长度（直接保存最长公共子序列的中间结果不现实，需要先借助LCS的长度）。其中X = {x1 … xm}，Y ={y1…yn}，Xi = {x1 … xi}，Yj={y1… yj}。可得递归公式如下：</p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200901165428404.png" alt="image-20200901165428404"></p><h4 id="5-计算LCS的长度"><a href="#5-计算LCS的长度" class="headerlink" title="5.计算LCS的长度"></a>5.计算LCS的长度</h4><p><strong>云盘视频</strong></p><pre><code>2、长江游艇俱乐部在长江上设置了n个游艇出租站1,2…n.游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为r(i，j)，其中1&lt;=i&lt;j&lt;=n；求：①用动态规划法求解时,计算最优值（最少租金）的递归公式？②设计计算最优值（最少租金）的算法？　　③并分析其时间复杂度？</code></pre><pre><code>解：①②计算最优值算法public static void matrixChain(int [] p, int [][] m, int [][] s)   {      int n=p.length-1;      for (int i = 1; i &lt;= n; i++) 　　m[i][i] = 0;  　//1个站      for (int r = 2; r &lt;= n; r++)         for (int i = 1; i &lt;= n - r+1; i++)         { int j=i+r-1;            m[ i][ j] = m[i][i]  +  m[i+1][ j];            s[ i][ j] = i;　　　　 //断点位置在i处            for (int k = i+1; k &lt; j; k++)             {int　 t  = m[ i][ k]  + m[k+1][ j];               if (t &lt; m[i][j])             {       m[ i][ j] = t;           s[ i][ j] = k;}                  } } }构造最优解算法public void  traceback( int s[][],int I,int j){if(i=j)   return;traceback( s,  i,  s[ i][ j] );traceback( s,  s[ i][ j]+1,  j );System.out.println(“A”+ i +“，”+ s[ i][ j] + “A”+ s[ i][ j]+1 +“,”+ j )}         //(m[ i, s[ i][ j] ] ) (m[ s[ i][ j]+1,  j ] )③时间复杂度：O(n3)</code></pre><h2 id="第四章-贪心法"><a href="#第四章-贪心法" class="headerlink" title="第四章 贪心法"></a>第四章 贪心法</h2><p>名词解释：</p><p><strong>二元前缀码</strong>：</p><p>定义14.1 设A = {a1,a2,…,am}是一个符号串集合，若对任意ai,aj∈A，ai≠aj，ai不是aj的前缀，aj也不是ai的前缀，则称A为前缀码（Prefixed Code）。若符号串ai（i = 1,2…,m）中，只出现0和1两个符号，则称A为二元前缀码（Binary Prefixed Code）。</p><pre><code>前缀码在计算机及通信中，常用二进制bai编码来表示字符。例如，可用00、01、10、11分别表示字母A、B、C、D。如果字母A、B、C、D出现的频率是一样的，传输100个字母用200个二进制位。但实际上字母出现的频率很不一样，如A出现的频率为50％，B出现的频率为25％，C出现的频率为20％，D出现的频率为5％。能否用不等长的二进制序列表示字母A、B、C、D，使传输的信息的二进制位尽可能少呢？事实上，可用000表示字母D，用001表示字母C，01表示B，1表示A。这样表示，传输100个字母所用的二进制位为3×5 + 3×20 + 2×25 + 1×50 = 175这种表示比用等长的二进制序列表示法好，节省了二进制位。但当我们用1表示A，用00表示B，用001表示C，用000表示D时，如果接收到的信息为001000，则无法辨别它是CD还是BAD。因而，不能用这种二进制序列表示A、B、C、D。要寻找另外的表示法。设a1a2…an-1an为长度为n的符号串，称其子串a1，a1a2，…,a1a2…an-1分别为a1a2…an-1an的长度为1，2，…，n-1的前缀（Prefix）。定义14.1 设A = {a1,a2,…,am}是一个符号串集合，若对任意ai,aj∈A，ai≠aj，ai不是aj的前缀，aj也不是ai的前缀，则称A为前缀码（Prefixed Code）。若符号串ai（i = 1,2…,m）中，只出现0和1两个符号，则称A为二元前缀码（Binary Prefixed Code）。例如{1,01,001,000}是前缀码，而{1,11,001,0011}不是前缀码。那么如何产生前缀码呢？可用一棵二元树来产生一个二元前缀码。给定一棵二元树T，假设它有t片树叶。设v是T任意一个分支点，则v至少有一个儿子至多有两个儿子。若v有两个儿子，则在由v引出的两条边上，左边的标上0，右边的标上1；若v只有一个儿子，在v引出的边上可标0也可标1。设vi为T的任意一片树叶，从树根到vi的通路上各边的标号组成的符号串放在vi处，t片树叶处的t个符号串组成的集合为一个二元前缀码。由上述作法可知，vi中的符号串的前缀均在vi所在的通路上，因而所得集合为二元（0和1组成）前缀码。由此法可知，若T存在带一个儿子的分支点，则由T产生的前缀码不惟一，但T若为完全二元树，则T产生的前缀码就是惟一的了。图14-6中所示的二元树产生的前缀码为：{1,00,010,011}。当知道了传输的符号出现的频率时，如何选择前缀码，使传输的二进制位尽可能地少呢？这就要先产生一棵最优二元树T，然后用T产生二元前缀码，能使传输的二进制位最少。下面通过一个例子来说明最优前缀码的产生过程。已知字母A、B、C、D、E、F出现的频率如下：A——30％，B——25％，C——20％，D——10％，E——10％，F——5％。（1）求带权30，25，20，10，10，5的最优二元树T（2）在T上求一个前缀码。（3）设树叶vi带权为w％×100 = w，则vi处的符号串表示出现频率为w％的字母。A = {01,10,11,001,0001,0000}为一前缀码，其中0000表示F，0001表示E，001表示D，01表示C，10表示B，11表示A。传输100个这样的字母所用的二进制位为4×(5 + 10) + 3×10 + 2×(20 + 25 + 30) = 240</code></pre><p><strong>最小生成树</strong>：一个有 n 个结点的<a href="https://baike.baidu.com/item/连通图/6460995" target="_blank" rel="noopener">连通图</a>的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p><h3 id="0-题目-1"><a href="#0-题目-1" class="headerlink" title="0.题目"></a>0.题目</h3><pre><code>四．Prim算法和Kruskal算法的比较：1. Prim算法：保证S所代表的子图是一棵树的前提下，选择一条最小代价的边e=(u,v);2. Kruskal算法：构造生成树的过程中，边集S代表的子图不一定是连通的；按边代价的非减次序考察E中的边，从中选择一条代价最小的边e=(u,v)；3. Prim算法：由于Prim算法中每次选取的边两端总是一个已连通顶点和一个未连通顶点，故这个边选取后一定能将该未连通点连通而又保证不会形成回路；因此没选择一条边后，无须再判断边集S Ue是否包含回路；4. Kruskal算法：为了确保最终得到生成树，每选择一条边时，都需要判定边集S Ue是否包含回路。</code></pre><pre><code>一、选择题：1．哈弗曼编码的贪心算法所需的计算时间为（   B     ）。A、O（n2n）        B、O（nlogn）        C、O（2n）        D、O（n）2 .下面是贪心算法的基本要素的是（      C     ）。A、重叠子问题        B、构造最优解        C、贪心选择性质        D、定义最优解</code></pre><h3 id="0-1-哈夫曼编码"><a href="#0-1-哈夫曼编码" class="headerlink" title="0.1 哈夫曼编码"></a>0.1 哈夫曼编码</h3><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908113613290.png" alt="image-20200908113613290"></p><h3 id="一．基础"><a href="#一．基础" class="headerlink" title="一．基础"></a>一．基础</h3><p>1.<strong>可行解</strong>：满足约束条件的解；</p><p>2.<strong>最优解</strong>：使目标函数取得最大（或最小）值的可行解，它用来衡量可行解的好坏；</p><p>3.<strong>贪心法</strong>是一种求解最优化问题的算法设计策略。</p><p>4.<strong>贪心法的应用领域</strong>有：背包问题、最小代价生成树（Kruskal算法和Prim算法）、哈夫曼树、文件的最佳合并树等；</p><p>5.贪心法是通过<strong>分步决策</strong>的方法来求解问题的，贪心法每一步上用作决策依据的选择准则被称为最优量度标准（局部最优解）；</p><h3 id="二、可以用贪心法求解的问题一般具有两个重要性质"><a href="#二、可以用贪心法求解的问题一般具有两个重要性质" class="headerlink" title="二、可以用贪心法求解的问题一般具有两个重要性质"></a>二、<strong>可以用贪心法求解的问题一般具有两个重要性质</strong></h3><p>1.<strong>贪心选择性质</strong>：所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到；（这是贪心法和动态规划法的主要区别）</p><p>2.<strong>最优子结构性质</strong>：一个问题的最优解包含其子问题的最优解（这是贪心法和动态规划算法的共同特征）</p><h3 id="三、贪心法的经典应用背包问题"><a href="#三、贪心法的经典应用背包问题" class="headerlink" title="三、贪心法的经典应用背包问题"></a>三、贪心法的经典应用背包问题</h3><p>1.首先计算每种物品单位重量的价值pi/wi并按非增次序进行排序；</p><p>2.然后依贪心选择策略，选择单位重量价值最高的物品装入背包；依此策略一直地进行下去，将尽可能多的物品全部装入背包，直到将背包装满；</p><p>3.若装入某件物品时，不能全部装下，而背包内的物品总重量仍未达到w，则根据背包的剩余载重，选择单位重量价值次高的物品并尽可能多地装入背包。（参考例题）</p><h3 id="四．Prim算法和Kruskal算法"><a href="#四．Prim算法和Kruskal算法" class="headerlink" title="四．Prim算法和Kruskal算法"></a>四．Prim算法和Kruskal算法</h3><p><strong>云盘视频</strong></p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902174429146.png" alt="image-20200902174429146"></p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902174531466.png" alt="image-20200902174531466"></p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902174716034.png" alt="image-20200902174716034"></p><h3 id="五．贪心法的基本要素"><a href="#五．贪心法的基本要素" class="headerlink" title="五．贪心法的基本要素"></a>五．<strong>贪心法的基本要素</strong></h3><p>1.<strong>最优量度标准</strong>：</p><p>（1）选择最优量度标准是使用贪心法求解问题的核心问题；</p><p>（2）贪心算法每一步作出的选择可以依赖以前作出的选择，但不依赖将来的选择，也不依赖一子问题的解；</p><p>（3）对于一个贪心算法，必须证明所采用的量度标准能够导致一个整体最优解；</p><p>2.<strong>最优子结构特性</strong>：见本章</p><h3 id="六．一个问题能够使用贪心策略的条件"><a href="#六．一个问题能够使用贪心策略的条件" class="headerlink" title="六．一个问题能够使用贪心策略的条件"></a>六．<strong>一个问题能够使用贪心策略的条件</strong></h3><p>1.问题的解是向量结构（n元组形式）；</p><p>2.具有最优子结构特性；</p><p>3.能够获取最优量度标准；</p><p>4.能证明是最优解。</p><pre><code>1、对下图所示的连通网络 G，用克鲁斯卡尔 (Kruskal) 算法求 G 的最小生成树T, 请写出在算法执行过程中，依次加入 T 的边集 TE 中的边。说明该算法的贪心策略和算法的基本思想，并简要分析算法的时间复杂度。</code></pre><p> <img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902170210796.png" alt="image-20200902170210796"></p><p>先把边都列出来，然后按权值排序小到大,然后回进去n-1条就行，环不行</p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902170243081.png" alt="image-20200902170243081"></p><pre><code>2、给定下图G＝(V, E)是一个无向连通图，对每一条边(v, w),其权值为c( v, w)；求：①利用prim算法构造其最小生成树，画出其选边的过程？　　　并构造其算法？并分析其时间复杂度？②利用kruskal算法构造其最小生成树，画出其选边的过程？　　　并构造其算法？并分析其时间复杂度？</code></pre><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902170305915.png" alt="image-20200902170305915"></p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902170340427.png" alt="image-20200902170340427"></p><p>Prim算法：按顺序，从0-n，选权值最小的，不能有环，顶点一个一个加进去</p><p> <img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200902170420915.png" alt="image-20200902170420915"></p><h2 id="第五章-回溯法"><a href="#第五章-回溯法" class="headerlink" title="第五章 回溯法"></a>第五章 回溯法</h2><h3 id="0-题目-2"><a href="#0-题目-2" class="headerlink" title="0.题目"></a>0.题目</h3><pre><code>一、选择题：1．下列算法中通常以深度优先方式系统搜索问题解的是（  D   ）。A、备忘录法        B、动态规划法        C、贪心法         D、回溯法2. 回溯法的效率不依赖于下列哪些因素（   D     ）A. 满足约束的值的个数                 B. 计算约束函数的时间  C. 计算限界函数的时间                 D. 确定解空间的时间3.下面哪种函数是回溯法中为避免无效搜索采取的策略（    B    ）A．递归函数        B.剪枝函数            C。随机数函数            D.搜索函数</code></pre><pre><code>二、简答题1、简述回溯法和分支限界法的相同点和不同点？共同点：1.都是在问题的状态空间树上搜索问题解的算法；2.都用活结点表实现，都可用约束函数剪去不含答案结点的分枝，都可用限界函数剪去不含最优解的分枝。不同点：1.求解目标不同：回溯法的求解目标是找出解空间树中满足约束条件的所有可行解；而分枝限界法的求解目标则是找出满足约束条件的一个可行解，或某种意义下的最优解。2.搜索方式不同：回溯法以深度优先的方式搜索解空间，而分枝限界法则以广度优先或最小耗费优先的方式搜索解空间树。3.对当前扩展结点的扩展方式不同：回溯法中的每个活结点可能多次成为当前扩展结点，纵深方向扩其一个孩子，然后再回溯后扩展其他孩子；而分枝限界法中每一个活结点只有一次机会成为扩展结点，一次产生所有孩子结点，自身成为死结点，之后无需再返回该结点处。</code></pre><pre><code>2、什么是子集树？ 什么是排列树？什么叫完全m叉树？子集树是一个数学学科词汇，属于函数类，当所给问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间称为子集树。排列树是一种用来解决组合数学问题特殊的图。完全m叉树是数据结构的专业术语，在根树中（外向树），如果任何结点的出度最多为m则称为m叉树；进一步如果他的叶都在同一层那么称为正则m叉树，也叫满m次树。</code></pre><pre><code>3、回溯算法的基本思想？　回溯法又称试探bai法。回溯法的基du本做法是深度优先zhi搜索，是一种组织得井井有条的、能避dao免不必要重复搜索的穷举式搜索算法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。当我们遇到某一类问题时，它的问题可以分解，但是又不能得出明确的动态规划或是递归解法，此时可以考虑用回溯法解决此类问题。回溯法的优点在于其程序结构明确，可读性强，易于理解，而且通过对问题的分析可以大大提高运行效率。但是，对于可以得出明显的递推公式迭代求解的问题，还是不要用回溯法，因为它花费的时间比较长。对于用回溯法求解的问题，首先要将问题进行适当的转化，得出状态空间树。这棵树的每条完整路径都代表了一种解的可能。通过深度优先搜索这棵树，枚举每种可能的解的情况；从而得出结果。但是，回溯法中通过构造约束函数，可以大大提升程序效率，因为在深度优先搜索的过程中，不断的将每个解（并不一定是完整的，事实上这也就是构造约束函数的意义所在）与约束函数进行对照从而删除一些不可能的解，这样就不必继续把解的剩余部分列出从而节省部分时间。回溯法中，首先需要明确下面三个概念：（一）约束函数：约束函数是根据题意定出的。通过描述合法解的一般特征用于去除不合法的解，从而避免继续搜索出这个不合法解的剩余部分。因此，约束函数是对于任何状态空间树上的节点都有效、等价的。（二）状态空间树：刚刚已经提到，状态空间树是一个对所有解的图形描述。树上的每个子节点的解都只有一个部分与父节点不同。（三）扩展节点、活结点、死结点：所谓扩展节点，就是当前正在求出它的子节点的节点，在深度优先搜索中，只允许有一个扩展节点。活结点就是通过与约束函数的对照，节点本身和其父节点均满足约束函数要求的节点；死结点反之。由此很容易知道死结点是不必求出其子节点的（没有意义）。</code></pre><pre><code>1、n皇后问题在4×4格的棋盘上放置彼此不受攻击的4个皇后。按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。用回溯算法解决4皇后问题：            ①构造求解该问题的解空间树？         ②设计该4皇后问题的回溯算法？     解：①解空间树  </code></pre><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908114629232.png" alt="image-20200908114629232"></p><p>②回溯算法</p><h2 id="第六章-线性规划"><a href="#第六章-线性规划" class="headerlink" title="第六章 线性规划"></a>第六章 线性规划</h2><h3 id="1-基本要求"><a href="#1-基本要求" class="headerlink" title="1.基本要求"></a>1.基本要求</h3><p>㈠基本要求 理解线性规划算法模型，网络与网络流的基本概念；掌握线性规划的单纯形算法， 网络最大流的增广路算法、预流推进算法，网络最小费用流的消圈算法、最小费用路算法、网络单纯形算法。</p><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><p>㈡教学重点线性规划的基本概念；单纯形算法；最大网络流和最小费用流问题的解法。</p><h3 id="3-最大网络流和最小费用流"><a href="#3-最大网络流和最小费用流" class="headerlink" title="3.最大网络流和最小费用流"></a>3.最大网络流和最小费用流</h3><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908114846329.png" alt="image-20200908114846329"></p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908114859818.png" alt="image-20200908114859818"></p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908114913325.png" alt="image-20200908114913325"></p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908114924558.png" alt="image-20200908114924558"></p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908114932886.png" alt="image-20200908114932886"></p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908114946387.png" alt="image-20200908114946387"></p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908114957810.png" alt="image-20200908114957810"></p><h2 id="第七八九章"><a href="#第七八九章" class="headerlink" title="第七八九章"></a>第七八九章</h2><pre><code>一．选择题1、下面关于NP问题说法正确的是（B ）A NP问题都是不可能解决的问题    B P类问题包含在NP类问题中C NP完全问题是P类问题的子集     D NP类问题包含在P类问题中2、蒙特卡罗算法是（   B      ）的一种。    A、分支界限算法      B、概率算法    C、贪心算法    D、回溯算法3.下列哪一种算法不是随机化算法（    C     ）A. 蒙特卡罗算法B. 拉斯维加斯算法C.动态规划算法D.舍伍德算法4、下列随机算法中运行时有时候成功有时候失败的是（C ）A 数值概率算法 B 舍伍德算法 C 拉斯维加斯算法 D 蒙特卡罗算法5、在下列算法中得到的解未必正确的是（  B      ）。A、蒙特卡罗算法    B、拉斯维加斯算法   C、舍伍德算法   D、数值概率算法6、舍伍德算法是（    B     ）的一种。A、分支界限算法      B、概率算法    C、贪心算法    D、回溯算法7、在下列算法中有时找不到问题解的是（  B      ）。A、蒙特卡罗算法    B、拉斯维加斯算法   C、舍伍德算法   D、数值概率算法1、什么是易解问题？什么是难解问题？难解问题分为哪两类？答：1）易解问题：人们将存在多项式时间 算法的问题称为易解问题;2）难解问题：将需要在指数时间内解决的问题称为难解问题；3）难解问题有两类：  1）不可判定问题  　 2）非决定的难处理问题 。2、什么是不可判定问题？什么是非决定的难处理问题？答：1）不可判定问题 ：该类问题是不能解问题，它们太难了，以至于根本就不存在能求解它们的任何算法。2）非决定的难处理问题：  这类问题是可判定的（即可解的）。 但是，这类问题即使使用非决定的计算机，也不能在多项式时间内求解它们。3、什么是P类问题？什么是NP完全问题？答：1）P类问题：是一类能够用确定性算法在多项式时间内求解的判断问题。事实上，所有易解问题都属于P类问题。2）NP完全问题：对于某问题，很难找到其多项式时间的算法(或许根本不存在)，但是如果给了该问题的一个答案，则可以在多项式时间内判定或验证这个答案是否正确。 这种可以在多项式时间内验证一个解是否正确的问题称为NP问题。4、列出几个典型的NP完全问题？答：（1）图着色问题COLORING（2）路径问题LONG-PATH （3）顶点覆盖问题VERTEX-COVER（4）子集和问题SUBSET-SUM（5）哈密尔顿回路问题HAM-CYCLE（6）旅行商问题TSP（7）装箱问题BIN-PACKING ，   能否用k个箱子来装n个物品；1、    所有NP完全问题都还没有多项式时间的算法，然而许多NP完全问题都具有很重要的意义，对于这类问题通常可以采取以下几种解题策略？答：１）只对问题的特殊实例求解； 　  ２）用动态规划或分支限界法求解。    ３）启发式方法求解    ４）只求近似解2、什么是问题的计算复杂度？它与时间复杂度的关系是什么？一、计算复杂度我们知道，计算机中的算法复杂度，定义为只和问题规模N有关，即计算复杂度是N的一个函数 f(N)。如果计算复杂度只相差一个常数因子，则认为复杂度是同一数量级的，是相同的，即 f(N) = Nlog(N) 和 g(N) = 100Nlog(N) 的复杂度是相同的。所以我们干脆引进算子O()来描述算法复杂度。上述 f(N) 和 g(N) 均表示为 O(N logN)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人工智能</title>
      <link href="/2020/092226468.html"/>
      <url>/2020/092226468.html</url>
      
        <content type="html"><![CDATA[<h1 id="人工智能作业"><a href="#人工智能作业" class="headerlink" title="人工智能作业"></a>人工智能作业</h1><h2 id="1-第一章："><a href="#1-第一章：" class="headerlink" title="1.第一章："></a>1.第一章：</h2><pre><code>1.为什么神经网络在人工智能第一次浪潮中并没有获得成功，而如今却获得突飞猛进的进展？答：    50年代末，F·Rosenblatt设计制作了“感知机”，它是一种多层的神经网络。这项工作首次把人工神经网络的研究从理论探讨付诸工程实践。当时，世界上许多实验室仿效制作感知机，分别应用于文字识别、声音识别、声纳信号识别以及学习记忆问题的研究。然而，这次人工神经网络的研究高潮未能持续很久，许多人陆续放弃了这方面的研究工作，这是因为当时数字计算机的发展处于全盛时期，许多人误以为数字计算机可以解决人工智能、模式识别、专家系统等方面的一切问题，使感知机的工作得不到重视；其次，当时的电子技术工艺水平比较落后，主要的元件是电子管或晶体管，利用它们制作的神经网络体积庞大，价格昂贵，要制作在规模上与真实的神经网络相似是完全不可能的；另外，在1968年一本名为《感知机》的著作中指出线性感知机功能是有限的，它不能解决如异或这样的基本问题，而且多层网络还不能找到有效的计算方法，这些论点促使大批研究人员对于人工神经网络的前景失去信心。60年代末期，人工神经网络的研究进入了低潮。另外，在60年代初期，Widrow提出了自适应线性元件网络，这是一种连续取值的线性加权求和阈值网络。后来，在此基础上发展了非线性多层自适应网络。当时，这些工作虽未标出神经网络的名称，而实际上就是一种人工神经网络模型。随着人们对感知机兴趣的衰退，神经网络的研究沉寂了相当长的时间。80年代初期，模拟与数字混合的超大规模集成电路制作技术提高到新的水平，完全付诸实用化，此外，数字计算机的发展在若干应用领域遇到困难。这一背景预示，向人工神经网络寻求出路的时机已经成熟。美国的物理学家Hopfield于1982年和1984年在美国科学院院刊上发表了两篇关于人工神经网络研究的论文，引起了巨大的反响。人们重新认识到神经网络的威力以及付诸应用的现实性。随即，一大批学者和研究人员围绕着 Hopfield提出的方法展开了进一步的工作，形成了80年代中期以来人工神经网络的研究热潮。</code></pre><h2 id="2-8数码问题"><a href="#2-8数码问题" class="headerlink" title="2.8数码问题"></a>2.8数码问题</h2><pre><code>在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。</code></pre><p><strong>分析】</strong></p><p>题目读完第一感觉是和求解最短路径问题类似，考虑使用BFS，状态很好找，每次移动空格就会形成一种新的状态，例如：</p><p><img src="https://img-blog.csdn.net/20180116201941897?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjI4MzQ2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><img src="https://s1.ax1x.com/2020/09/22/wXE9LF.png" alt="wXE9LF.png"></p><p><img src="https://s1.ax1x.com/2020/09/22/wXEZz6.png" alt="wXEZz6.png"></p><p>八数码问题是个典型的状态图搜索问题。搜索方式有两种基本的方式，即树式搜索和线式搜索。搜索策略大体有盲目搜索和启发式搜索两大类。盲目搜索就是无“向导”的搜索，（例如深度优先搜索，广度优先搜索），其效率极其低下。启发式搜索就是有“向导”的搜索，有更好的效率</p><p><strong>一、状态如何表示？</strong></p><p>1.每个状态都用3*3的数组表示，但是BFS中需要入队出队，比较麻烦而且空间占用较大</p><p>2.状态压缩，采用一个整数保存状态的数字序列，例如状态1表示为283104765,状态2表示为203184765</p><p><strong>二、如何判重？</strong></p><p>1.如果空间允许，开一个876543210大小的bool数组，某个序列出现就将数组值置为1；但是竞赛中一般都是限制128M(大约10000000)，这个数组开不下来。</p><p>2.虽然状态范围是012345678–876543210，但是中间真正有效的只有9！=362800，因为数字不可能出现重复；因此可以考虑开一个数组大小为9！整型数组A和bool数组B，然后生成0-8这9个数码的全排列并按照升序或者降序存入数组中，要判断某个状态（一种排列方式）是否出现过，直接通过二分查找的方式找到该排列在A中的下标i，然后查看数组B[i]为true还是false；如果为true则出现过，如果为false则将状态入队，并设置B[i]=true;</p><p>3.其实从方案2中我们已经看到，判重的实质就是建立状态数字串（一个int数据）和是否出现（一个bool数据）之间的联系，而STL中刚好提供了map&lt;key,value&gt;这样一种容器，我们可以将状态数字串作为key，是否出现作为value直接建立起状态–是否出现的联系。</p><p>4.使用hash判重，将状态数字串通过某种映射f(x)从012345678–876543210这样一个大集合，映射到128M范围之内；这里采用简单的hash，取模一个大质数，只要这个质数大于9！即可；当然这里可能出现冲突，也就是key1!=key2但是f(key1)==f(key2),hash算法只能减少冲突不能避免冲突。这里如何减少冲突呢？挂链表，当key1!=key2但是f(key1)==f(key2),则将key2挂到key1后面；当然这里如果使用康托展开可以完美一一映射而不冲突，但是我不会(<del>^</del>)。</p><p><strong>三、搜索方法的选择</strong></p><p><strong>1.BFS（广度优先搜索）</strong></p><p>广度优先遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。</p><p>上文所述树的广度优先遍历动图如下，每个节点的值即为它们的遍历顺序。所以广度优先遍历也叫层序遍历，先遍历第一层(节点 1)，再遍历第二层(节点 2，3，4)，第三层(5，6，7，8)，第四层(9，10)。</p><p><img src="https://s2.51cto.com/oss/202004/16/29dc30c1546cc73846153359b0fad8fb.gif" alt="img"></p><p>深度优先遍历用的是栈，而广度优先遍历要用队列来实现，我们以下图二叉树为例来看看如何用队列来实现广度优先遍历。</p><p><img src="https://s4.51cto.com/oss/202004/16/1ba485c575477d00a51b44640671245e.png" alt="img"></p><p>动图如下：</p><p><img src="https://s4.51cto.com/oss/202004/16/a2c7c61edcadffeed85c10f53f1c988c.gif" alt="img"></p><pre><code>/**  * 使用队列实现 bfs  * @param root  */ private static void bfs(Node root) {     if (root == null) {         return;     }     Queue&lt;Node&gt; stack = new LinkedList&lt;&gt;();     stack.add(root);     while (!stack.isEmpty()) {         Node node = stack.poll();         System.out.println("value = " + node.value);         Node left = node.left;         if (left != null) {             stack.add(left);         }         Node right = node.right;         if (right != null) {             stack.add(right);         }     } } </code></pre><p>** 广度优先实现8数码**</p><pre><code>#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;ctime&gt;char ans[11],start[10];bool isUsed[11];int changeId[9][4]={{-1,-1,3,1},{-1,0,4,2},{-1,1,5,-1},                    {0,-1,6,4},{1,3,7,5},{2,4,8,-1},                    {3,-1,-1,7},{4,6,-1,8},{5,7,-1,-1}                    };//0出现在0-&gt;8的位置后该和哪些位置交换 const int M=400000;//9！=362800，因此数组开40W足够了 int num[M],len=0,des=123804765;//num存储所有排列，len表示排列的个数也就是9！，des为目的状态直接用整数表示便于比较 bool isV[M];//bfs时判断状态是否出现过；isV的下标和num的下标一一对应，表示某种排列是否出现过//通过isV和num建立起某种排列的组合成的整数int和bool的关系，其实STL中有map实现了key--&gt;value，用排列作为key，value用bool即可 int que[M][3];//0--&gt;排列,1--&gt;排列中0的位置,2--&gt;步数 void swap(char *c,int a,int b){//交换字符串中的两个位置     char t=c[a];    c[a]=c[b];    c[b]=t;}void paiLie(int n,int k){//深搜产生0-8的全排列     for(int i=0;i&lt;n;i++){        if(!isUsed[i]){            ans[k]=i+'0';            isUsed[i]=1;            if(k==n){//已经有n个转换存储                 ans[k+1]='\0';                sscanf(ans+1,"%d",&amp;num[len++]);            }            else                paiLie(n,k+1);            isUsed[i]=0;//回溯一步         }    }}int halfFind(int l,int r,int n){//二分查找     int mid=l+(r-l)/2;    if(num[mid]==n)return mid;    else if(l&lt;r&amp;&amp;num[mid]&gt;n)return halfFind(l,mid-1,n);    else if(l&lt;r&amp;&amp;num[mid]&lt;n) return halfFind(mid+1,r,n);    return -1;}int bfs(int n,int p){    int head=0,tail=1,temp;//head队头，tail队尾     que[head][0]=n,que[head][1]=p,que[head][2]=head;//初始状态保存到对头，并设置当前步数为0     while(head!=tail){//队列不为空则继续搜索         char cur[10];//用于保存当前状态的字符串         int  pos=que[head][1];//当前状态中0的位置         sprintf(cur,"%09d",que[head][0]);//int--&gt;char*这里的09d至关重要，否则算不出答案         for(int i=0;i&lt;4;i++){//扩展当前的状态，上下左右四个方向             int swapTo=changeId[pos][i];//将要和那个位置交换             if(swapTo!=-1){//-1则不交换                 swap(cur,pos,swapTo);//交换0的位置得到新状态                 sscanf(cur,"%d",&amp;temp);//新状态转换为int保存到temp                 if(temp==des)//如果是目标状态则返回当前状态的步数+1                     return que[head][2]+1;                int k=halfFind(0,len,temp);//没有返回就查找当前排列的位置，将查出来的下标作为isV的下标                 if(!isV[k]){//如果 没有出现过，则将这个新状态进队                     que[tail][0]=temp,que[tail][1]=swapTo,que[tail][2]=que[head][2]+1;                    tail++;                        isV[k]=1;                }                swap(cur,pos,swapTo);//一个新状态处理完了一定要记得将交换的0交换回来             }        }        head++;    }}int main(){    int n,i=-1,count=0;    paiLie(9,1);//先将0-8的全排列按照升序产生出来存入num数组     scanf("%s",start);//输入初始状态     while(start[++i]!='0');//查找初始状态0的位置     sscanf(start,"%d",&amp;n);//字符串转换为整数     //int s=clock();    if(n!=des)//判断输入状态是否就是目的状态         count=bfs(n,i);     printf("%d\n",count);    //printf("%.6lf",double(clock()-s)/CLOCKS_PER_SEC);    return 0;}</code></pre><p><strong>2.DFS（深度优先搜索）</strong></p><p>主要思路是从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。</p><p>1、我们从根节点 1 开始遍历，它相邻的节点有 2，3，4，先遍历节点 2，再遍历 2 的子节点 5，然后再遍历 5 的子节点 9。</p><p><img src="https://s4.51cto.com/oss/202004/16/ca375e4d1d4a377b4a15dc9e548123d1.png" alt="img"></p><p>2、上图中一条路已经走到底了(9是叶子节点，再无可遍历的节点)，此时就从 9 回退到上一个节点 5，看下节点 5 是否还有除 9 以外的节点，没有继续回退到 2，2 也没有除 5 以外的节点，回退到 1，1 有除 2 以外的节点 3，所以从节点 3 开始进行深度优先遍历，如下：</p><p><img src="https://s3.51cto.com/oss/202004/16/2354c3d3f9abc912f6500140ee92458a.png" alt="img"></p><p>3、同理从 10 开始往上回溯到 6, 6 没有除 10 以外的子节点，再往上回溯，发现 3 有除 6 以外的子点 7，所以此时会遍历 7。</p><p><img src="https://s2.51cto.com/oss/202004/16/7e0a19b7de2356a352661c4b0f803f71.png" alt="img"></p><p>3、从 7 往上回溯到 3， 1，发现 1 还有节点 4 未遍历，所以此时沿着 4， 8 进行遍历,这样就遍历完成了。</p><p>完整的节点的遍历顺序如下(节点上的的蓝色数字代表)：</p><p><img src="https://s5.51cto.com/oss/202004/16/92f602a1eaa301784085b8a3c4b948c0.png" alt="92f602a1eaa301784085b8a3c4b948c0.png (381×337)"></p><p>看到以上的遍历不难发现这就是树的前序遍历,实际上不管是前序遍历，还是中序遍历，亦或是后序遍历，都属于深度优先遍历。</p><p>那么深度优先遍历该怎么实现呢，有递归和非递归两种表现形式，接下来我们以二叉树为例来看下如何分别用递归和非递归来实现深度优先遍历。</p><p><strong>1、递归实现</strong></p><p>递归实现比较简单，由于是前序遍历，所以我们依次遍历当前节点，左节点，右节点即可，对于左右节点来说，依次遍历它们的左右节点即可，依此不断递归下去，直到叶节点(递归终止条件)，代码如下：</p><pre><code>public class Solution {     private static class Node {         /**          * 节点值          */         public int value;         /**          * 左节点          */         public Node left;         /**          * 右节点          */         public Node right;         public Node(int value, Node left, Node right) {             this.value = value;             this.left = left;             this.right = right;         }     }     public static void dfs(Node treeNode) {         if (treeNode == null) {             return;         }         // 遍历节点         process(treeNode)         // 遍历左节点         dfs(treeNode.left);         // 遍历右节点         dfs(treeNode.right);     } } </code></pre><p>递归的表达性很好，也很容易理解，不过如果层级过深，很容易导致栈溢出。所以我们重点看下非递归实现。</p><p><strong>2、非递归实现</strong></p><p>仔细观察深度优先遍历的特点，对二叉树来说，由于是先序遍历(先遍历当前节点，再遍历左节点，再遍历右节点)，所以我们有如下思路：</p><p>对于每个节点来说，先遍历当前节点，然后把右节点压栈，再压左节点(这样弹栈的时候会先拿到左节点遍历，符合深度优先遍历要求)。</p><p>弹栈，拿到栈顶的节点，如果节点不为空，重复步骤 1， 如果为空，结束遍历。</p><p>我们以以下二叉树为例来看下如何用栈来实现 DFS。</p><p><img src="https://s2.51cto.com/oss/202004/16/b2a7d9fdc8fa1898a569255957428d94.png" alt="b2a7d9fdc8fa1898a569255957428d94.png (355×287)"></p><p>整体动图如下：</p><p><img src="https://s1.51cto.com/oss/202004/16/e1e6a44251b69cd3b930f3071a71ffd8.gif" alt="e1e6a44251b69cd3b930f3071a71ffd8"></p><p>整体思路还是比较清晰的，使用栈来将要遍历的节点压栈，然后出栈后检查此节点是否还有未遍历的节点，有的话压栈，没有的话不断回溯(出栈)，有了思路，不难写出如下用栈实现的二叉树的深度优先遍历代码：</p><pre><code>/**  * 使用栈来实现 dfs  * @param root  */ public static void dfsWithStack(Node root) {     if (root == null) {         return;     }     Stack&lt;Node&gt; stack = new Stack&lt;&gt;();     // 先把根节点压栈     stack.push(root);     while (!stack.isEmpty()) {         Node treeNode = stack.pop();         // 遍历节点         process(treeNode)         // 先压右节点         if (treeNode.right != null) {             stack.push(treeNode.right);         }         // 再压左节点         if (treeNode.left != null) {             stack.push(treeNode.left);         }     } } </code></pre><p><strong>深度优先实现8数码</strong></p><pre><code>#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;ctime&gt;char ans[11],start[10];bool isUsed[11];int changeId[9][4]={{-1,-1,3,1},{-1,0,4,2},{-1,1,5,-1},                    {0,-1,6,4},{1,3,7,5},{2,4,8,-1},                    {3,-1,-1,7},{4,6,-1,8},{5,7,-1,-1}                    };//0出现在0-&gt;8的位置后该和哪些位置交换 const int M=400000;//9！=362800，因此数组开40W足够了 int num[M],len=0,des=123804765;//num存储所有排列，len表示排列的个数也就是9！，des为目的状态直接用整数表示便于比较 int isV[M][2];//bfs时判断状态是否出现过；isV的下标和num的下标一一对应，表示某种排列是否出现过//通过isV和num建立起某种排列的组合成的整数int和bool的关系，其实STL中有map实现了key--&gt;value，用排列作为key，value用bool即可 int que1[M/2][3],que2[M/2][3];//0--&gt;排列,1--&gt;排列中0的位置,2--&gt;步数 void swap(char *c,int a,int b){//交换字符串中的两个位置     char t=c[a];    c[a]=c[b];    c[b]=t;}void paiLie(int n,int k){//深搜产生0-8的全排列     for(int i=0;i&lt;n;i++){        if(!isUsed[i]){            ans[k]=i+'0';            isUsed[i]=1;            if(k==n){//已经有n个转换存储                 ans[k+1]='\0';                sscanf(ans+1,"%d",&amp;num[len++]);            }            else                paiLie(n,k+1);            isUsed[i]=0;//回溯一步         }    }}int halfFind(int l,int r,int n){//二分查找     int mid=l+(r-l)/2;    if(num[mid]==n)return mid;    else if(l&lt;r&amp;&amp;num[mid]&gt;n)return halfFind(l,mid-1,n);    else if(l&lt;r&amp;&amp;num[mid]&lt;n) return halfFind(mid+1,r,n);    return -1;}bool expand(int head,int &amp;tail,int who,int q[][3]){    char cur[10];//用于保存当前状态的字符串     int  pos=q[head][1],temp;//当前状态中0的位置    sprintf(cur,"%09d",q[head][0]);//int--&gt;char*这里的09d至关重要，否则算不出答案     for(int i=0;i&lt;4;i++){//扩展当前的状态，上下左右四个方向         int swapTo=changeId[pos][i];//将要和那个位置交换         if(swapTo!=-1){//-1则不交换             swap(cur,pos,swapTo);//交换0的位置得到新状态             sscanf(cur,"%d",&amp;temp);//新状态转换为int保存到temp             int k=halfFind(0,len,temp);//没有返回就查找当前排列的位置，将查出来的下标作为isV的下标             if(isV[k][0]==0){//如果 没有出现过，则将这个新状态进队                 q[tail][0]=temp,q[tail][1]=swapTo,q[tail][2]=q[head][2]+1;                isV[k][0]=who;                isV[k][1]=tail;                tail++;            }            else if(isV[k][0]&amp;&amp;isV[k][0]!=who){                if(who==1)                    printf("%d", q[head][2]+que2[isV[k][1]][2]+1);                else                    printf("%d", q[head][2]+que1[isV[k][1]][2]+1);                return true;            }            swap(cur,pos,swapTo);//一个新状态处理完了一定要记得将交换的0交换回来         }    }    return false;}void bfs(int n,int p){    int head1=0,tail1=1,head2=0,tail2=1;//head队头，tail队尾     que1[head1][0]=n,que1[head1][1]=p,que1[head1][2]=head1;//初始状态保存到对头，并设置当前步数为0     que2[head2][0]=des,que2[head2][1]=4,que2[head2][2]=head2;//初始状态保存到对头，并设置当前步数为0     int k=halfFind(0,len,n);    isV[k][0]=1,isV[k][1]=0;    k=halfFind(0,len,des);    isV[k][0]=2,isV[k][1]=0;    while(head1!=tail1||tail2!=head2){//队列不为空则继续搜索         if(tail2-head2&gt;=tail1-head1){//2比1元素多就把1扩展             if(expand(head1,tail1,1,que1))return;             head1++;        }        else{            if(expand(head2,tail2,2,que2))return;             head2++;        }    }}int main(){//812340756    int n,i=-1,count=0;    paiLie(9,1);//先将0-8的全排列按照升序产生出来存入num数组     scanf("%s",start);//输入初始状态     while(start[++i]!='0');//查找初始状态0的位置     sscanf(start,"%d",&amp;n);//字符串转换为整数    //int s=clock();     if(n!=des)//判断输入状态是否就是目的状态         bfs(n,i);     else        printf("%d",count);    //printf("\n%.6lf",double(clock()-s)/CLOCKS_PER_SEC);    return 0;}</code></pre><p><strong>3.启发式搜索</strong></p><p>  启发式搜索：启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无谓的搜索路径，提高了效率</p><p><strong>解决此问题的启发策略：</strong></p><p>每次移动的时候，正确位置数码的个数要大于交换前正确位置数码个数。</p><p>正确位置数码个数：每个数码的位置与最终格局的对比，如果位置相同，则说明此数码在正确位置。</p><p><img src="https://s1.ax1x.com/2020/09/22/wXe3FJ.png" alt="wXe3FJ.png"></p><p>图1.3中右边为最终格局，左边为当前格局，红色字体标识的数码为 正确位置数码，由此可以发现其正确位置的数码个数为4个。那么图1.2中正确数码如下图所示：</p><p><img src="https://s1.ax1x.com/2020/09/22/wXeYS1.png" alt="wXeYS1.png"></p><p>由上图所示可得，正确位置数码个数大于等于4的只有左下方的格局，那么下一步选择的就是左下方的格局，再次调用次算法如下图：</p><p><img src="https://s1.ax1x.com/2020/09/22/wXeg6P.png" alt="wXeg6P.png"></p><p>由八数码问题的部分状态图可以看出，从初始节点开始，在通向目标节点的路径上，各节点的数码格局同目标节点相比较，其数码不同的位置个数在逐渐减少，最后为零。所以，这个数码不同的位置个数便是标志一个节点到目标节点距离远近的一个启发性信息，利用这个信息就可以指导搜索。即可以利用启发信息来扩展节点的选择，减少搜索范围，提高搜索速度。</p><p> 启发函数设定。对于八数码问题，可以利用棋局差距作为一个度量。搜索过程中，差距会逐渐减少，最终为零，为零即搜索完成，得到目标棋局。</p><pre><code>/*程序名：八数码问题描述：主要函数列表：      1.show()     显示当前待调整数码矩阵      2.exchange() 交换数码中的 begin[row_one][column_one] 与 begin[row_two][column_two] 这两个数      3.judge()    判断待调整的数码与最终数码相比正确位置数码的个数      4.yidong()   将待调整数码从开始位置移动到终止位置，并将其过程输出      5.shuru()    有用户输入待调整的数码矩阵最初状态的数，并将其存入到begin[][]数组中其它说明：此程序运用到启发式搜索的策略，          （1）：将空格的地方存储零，这样便于操作          （2）：每次交换0上下左右4个方向元素的位置，当交换位置后正确数码个数 大于或等于 交换前正确数码的个数则算交换成功，                 交换成功则重复步骤2，失败的话则跳回上一轮交换。          （3）：当交换到最终所有的数码的位置都正确时结束*/#include"stdio.h"#define num 3 //宏定义数码的行列数为3/*显示当前待调整数码矩阵*/void show(int begin[num][num])  {    for(int i = 0; i &lt; num; i++)    {        for(int j = 0; j &lt; num; j++)            printf("%d ", begin[i][j]);        printf("\n");    }    printf("\n");}/*交换数码中的 begin[row_one][column_one] 与 begin[row_two][column_two] 这两个数*/void exchange(int begin[num][num], int row_one, int column_one, int row_two, int column_two)  {    int temp;    temp = begin[row_two][column_two] ;    begin[row_two][column_two] = begin[row_one][column_one];    begin[row_one][column_one] = temp;}/*判断待调整的数码与最终数码相比正确位置数码的个数*/int judge(int begin[num][num], int end[num][num]) {    int count=0;           //count记录数码中正确位置的个数    for(int i = 0; i &lt; num; i++)   //检查当前图形的正确度        for(int j = 0; j &lt; num; j++)        {            if(begin[i][j] == end[i][j] &amp;&amp; end[i][j] != 0)                count++;        }    return count;           //返回数码中正确位置的个数}/* 将待调整数码从开始位置移动到终止位置，并将其过程输出*/int yidong(int begin[num][num], int end[num][num]           , int right, int jishu, int ji_shu[50][3][3]           , int biaoji, int row, int column) //biaoji存储上一轮移动的反方向代号{     int temp_zhi;    show(begin);   //显示数组矩阵    if(jishu &gt;= 20)        return 0;    int node;  //,node为标记    int temp;               //存储当前待调整数码正确的个数    for(int q=0; q&lt;jishu; q++)  //检查交换后的end[][]图形是否先前已经遍历过了    {        node = 1;        for(int w=0; w&lt;num &amp;&amp; node; w++)            for(int r=0; r&lt;num &amp;&amp; node; r++)                if(ji_shu[q][w][r] != begin[w][r])                    node = 0;        if(node == 1)   //如果先前遍历过，返回0        {            return 0;        }    }    for(int i = 0; i &lt; num; i++)           for(int j = 0; j &lt; num; j++)            ji_shu[jishu][i][j] = begin[i][j];    if(right == num * num - 1)  //如果待调整数码与最终数码完全相同时，返回1        return 1;    if(row &gt; 0 &amp;&amp; biaoji != 0)             //存储0的位置不是在第一行    {        exchange(begin, row - 1, column, row , column);  //将0与其上面的元素交换存储位置        temp = judge(begin, end);        if(temp &lt; right)   //如果交换后正确数码的个数不大于原来正确数码的个数            exchange(begin, row - 1, column, row , column); //再将其交换回来                else if(temp &gt;= right)          //如果交换后正确数码的个数大于或等于原来正确数码的个数        {            temp_zhi = yidong(begin, end, temp, jishu+1, ji_shu, 2, row-1, column);             if( temp_zhi == 1)  //进行下一步的移动                 return 1;            exchange(begin, row - 1, column, row , column); //再将其交换回来        }    }    if(column &gt; 0 &amp;&amp; biaoji != 1)    {           exchange(begin, row, column - 1, row , column); //将0与其左边的元素交换存储位置        temp = judge(begin, end);                if(temp &lt; right)                 exchange(begin, row, column - 1, row , column);                    else if(temp &gt;= right)        {            temp_zhi = yidong(begin, end, temp, jishu+1, ji_shu ,3, row, column - 1);            if(temp_zhi == 1)                   return 1;            exchange(begin, row, column - 1, row , column);        }    }    if(row &lt; num-1 &amp;&amp; biaoji != 2)    {        exchange(begin, row + 1, column, row , column); //将0与其下面的元素交换存储位置        temp = judge(begin, end);            if(temp &lt; right)             exchange(begin, row + 1, column, row , column);        else if(temp &gt;= right)        {            temp_zhi =yidong(begin, end, temp, jishu+1, ji_shu, 0, row+1, column);           if(temp_zhi == 1)                return 1;           exchange(begin, row + 1, column, row , column);        }    }    if(column &lt; num-1 &amp;&amp; biaoji != 3)    {        exchange(begin, row, column + 1, row , column); //将0与其右边的元素交换存储位置        temp = judge(begin, end);            if(temp &lt; right)               exchange(begin, row, column + 1, row , column);                else if(temp &gt;= right)          {            temp_zhi = yidong(begin, end, temp, jishu+1, ji_shu, 1, row, column+1);            if(temp_zhi == 1)                 return 1;            exchange(begin, row, column + 1, row , column);            }    }    return 0;   //移动失败，返回0}/*有用户输入待调整的数码矩阵最初状态的数，并将其存入到begin[][]数组中*/void shuru(int begin[][num],int blank[])  {    int temp, node, zero = 0;    for (int i = 0; i &lt; num; i++)        for(int j = 0; j &lt; num; j++)        {            node = 1;            printf("请输入第%d行，第%d列的元素的值：", i+1, j+1);            scanf("%d", &amp;temp);            for (int q = 0; q &lt;= i &amp;&amp; node == 1; q++)  //当输入的值有重复的，提示重新输入                for (int w = 0; w &lt; j; w++)                    if(temp == begin[q][w])                    {                        printf("输入重复，请重新输入\n");                        node = 0;                        j--;                        break;                    }            if(temp &lt; 0 || temp &gt; num*num-1)   //当输入的值不是在数码的区间范围内时，提示重新输入            {                printf("请输入从%d到%d的数\n", zero, num*num-1);                node = 0;                j--;            }            if(node == 1)   //如果输入满足条件                {                if(temp == 0) //如果输入的值为零，由blank[0]记录行号，blank[1]记录列号                {                    blank[0] = i;                    blank[1] = j;                }                begin[i][j] = temp;//将满足条件的值存储起来            }        }}int main(){    int jishu = 0, ji_shu[50][3][3];//jishu存储已经遍历过的八数码图形的个数，jishu[][][]存储已经遍历过的八数码图形的形状    int row;     //存储数字零的行数    int column;  //存储数字零的列数    int begin[num][num], blank[2],count=1;         int end[num][num] = {1, 2, 3, 8, 0, 4, 7, 6, 5};  //给最终状态的数码矩阵赋值    printf ("-------%d数码游戏开始！--------\n", num);    shuru(begin, blank);   //输入带调整状态的数码矩阵的值    row = blank[0];    column = blank[1];    if(yidong (begin, end,judge(begin,end),jishu,ji_shu,4,row,column) == 0)         printf("\n此8数码的问题可能无解！");    else        show(begin);    getchar();getchar();    return 0;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>辽大自动疫情打卡</title>
      <link href="/2020/072037829.html"/>
      <url>/2020/072037829.html</url>
      
        <content type="html"><![CDATA[<pre><code># 实现浏览器打开搜索# 引入webdriverfrom selenium.webdriver.common.keys import Keysfrom selenium import webdriverfrom openpyxl import load_workbookimport scheduledef job():        # 打开excel文件，获取处于活跃状态的表格        workbook = load_workbook(filename='num.xlsx')        sheet = workbook.active        for i in [2, 3, 4, 5 ,6 ,7 ,8 ,9]:                # 实列化对象，选择启用谷歌，打开浏览器                driver = webdriver.Chrome()                driver.implicitly_wait(10)                # 访问网页                driver.get("http://tjxx.lnu.edu.cn/login.asp")                # 输入账号                cell1 = sheet.cell(row=i, column=1).value                ele = driver.find_element_by_name("userid")                ele.send_keys(cell1)                # 输入密码                paw = sheet.cell(row=i, column=2).value                ele1 = driver.find_element_by_name("userpwd")                ele1.send_keys(paw)                # 点击登录                driver.find_element_by_id("formSubmitBtn").click()                # 选中第一个无                ele4 = driver.find_element_by_xpath("/html/body/div[1]/form/div[3]/div[2]/label[1]/div[2]/input")                driver.execute_script("arguments[0].click();", ele4)                # 选中第二个无                ele5 = driver.find_element_by_xpath("/html/body/div[1]/form/div[4]/div[2]/label[1]/div[2]/input")                driver.execute_script("arguments[0].click();", ele5)                # 选中健康                ele6 = driver.find_element_by_xpath("/html/body/div[1]/form/div[5]/div[2]/label[1]/div[2]/input")                driver.execute_script("arguments[0].click();", ele6)                # 选中隔离                ele7 = driver.find_element_by_xpath("/html/body/div[1]/form/div[6]/div[2]/label[1]/div[2]/input")                driver.execute_script("arguments[0].click();", ele7)                # 是否在校                ele8 = driver.find_element_by_xpath("/html/body/div[1]/form/div[7]/div[2]/label[1]/div[2]/input")                driver.execute_script("arguments[0].click();", ele8)                # # 提交                # driver.find_element_by_xpath("/html/body/div[1]/form/div[8]/a").click()                # # 确认提交                # driver.find_element_by_xpath("/html/body/div[3]/div[2]/div[2]/a[2]").click()                # 退出                # driver.find_element_by_xpath("/html/body/div/div[2]/div[3]/a").click()                driver.quit()                print("提交成功")schedule.every().day.at("21:48").do(job)while True:    schedule.run_pending()time.sleep(3)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记</title>
      <link href="/2020/053054657.html"/>
      <url>/2020/053054657.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python学习笔记"><a href="#Python学习笔记" class="headerlink" title="Python学习笔记"></a>Python学习笔记</h1><h2 id="安装python和pycharm"><a href="#安装python和pycharm" class="headerlink" title="安装python和pycharm"></a>安装python和pycharm</h2><pre><code>自己百度多的是</code></pre><h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><pre><code>单行：#多行：''' '''中文编码声明注释：# -*- coding：utf-8 -*-(文件开始)                  #coding=编码</code></pre><h3 id="2-代码缩进"><a href="#2-代码缩进" class="headerlink" title="2.代码缩进"></a>2.代码缩进</h3><pre><code>缩进代替花括号</code></pre><h3 id="3-编码规范"><a href="#3-编码规范" class="headerlink" title="3.编码规范"></a>3.编码规范</h3><pre><code>1.import语句中导入一个模块：尽量避免一次导入多个模块2.每行不超过80个字符3.空行增加可读性4.运算符两参数之间两侧空格分隔5.避免在循环中使用+和+=累加字符串6.模块名短小，小写，可下划线分割7.包名短小，小写8.类名：首字母大写9.模块内部的类_加首字母大写10.函数，类的属性方法：小写和-分割11.使用单-  ：开头模块变量或函数是受保护的12.双--的开头实例变量或方法是私有的</code></pre><h3 id="4-保留字和标识符"><a href="#4-保留字和标识符" class="headerlink" title="4.保留字和标识符"></a>4.保留字和标识符</h3><pre><code>1.数字不开头2.严格区分大小写3.可以汉字但不要用4.下划线开头：单：保护变量   双：类的私有              双开头结尾：专用</code></pre><h3 id="5-六大基本数据类型"><a href="#5-六大基本数据类型" class="headerlink" title="5.六大基本数据类型"></a>5.六大基本数据类型</h3><h4 id="a-数字"><a href="#a-数字" class="headerlink" title="a.数字"></a>a.数字</h4><pre><code>round（0.1+0.2,小数点位数）：四舍五入函数</code></pre><h4 id="b-字符串"><a href="#b-字符串" class="headerlink" title="b.字符串"></a>b.字符串</h4><pre><code>1.''  '' ''  ''' ''':单行，多行2.转义字符</code></pre><h4 id="c-布尔类型"><a href="#c-布尔类型" class="headerlink" title="c.布尔类型"></a>c.布尔类型</h4><pre><code>1.True，False：首字母大写：True=1,False=0</code></pre><h3 id="6-数据类型转换"><a href="#6-数据类型转换" class="headerlink" title="6.数据类型转换"></a>6.数据类型转换</h3><pre><code>1.int（）2.float（）3.str（）4.hex（）：十六进制5.oct（）：八进制</code></pre><h3 id="7-基本输入输出"><a href="#7-基本输入输出" class="headerlink" title="7.基本输入输出"></a>7.基本输入输出</h3><pre><code>1.input（）：文本型：强制类型转换type（int（a））2.print（）：</code></pre><h3 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8.运算符"></a>8.运算符</h3><pre><code>1.算数运算符：/:浮点数  //:取整2.赋值运算符：+= -+ *= /= %=3.比较运算符：== != 4.逻辑运算符：and or not5.位运算:二进制计算：    位与&amp;：有0为0    位或|：有1为1    位取反~：0变1,1变0    位异或^:全0全1才为0    左移&lt;&lt;:左移舍去高位，最后补0    右移&gt;&gt;:右移高位舍去，最后补06.优先级：单目》算数》位运算》比较运算：括号改变</code></pre><h3 id="9-条件表达式"><a href="#9-条件表达式" class="headerlink" title="9.条件表达式"></a>9.条件表达式</h3><pre><code>c = a if a&gt;b else b:真左假右</code></pre><h3 id="10-流程控制"><a href="#10-流程控制" class="headerlink" title="10.流程控制"></a>10.流程控制</h3><h4 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h4><pre><code>顺序，选择，条件</code></pre><h4 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h4><pre><code>1.if 条件：  else：2.if 条件：   elif 条件：   else：3.</code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre><code>1.while 条件：    tab循环体2.for 迭代变量 in 对象：    tab 循环体    range（）：连续整数生成    range（起始：包括，结束：不包括，步长）3.没有do while4.嵌套  for 迭代变量 in 对象：      for 迭代变量 in 对象：</code></pre><h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><pre><code>break：continue：</code></pre><h4 id="pass空语句"><a href="#pass空语句" class="headerlink" title="pass空语句"></a>pass空语句</h4><pre><code>pass：占位</code></pre><h3 id="序列的运用"><a href="#序列的运用" class="headerlink" title="序列的运用"></a>序列的运用</h3><h4 id="索引（数组）"><a href="#索引（数组）" class="headerlink" title="索引（数组）"></a>索引（数组）</h4><pre><code>1.语法：string[0-n-1]2.可以是负数：从右向左计数-1开始：string[-2]3.切片：列表名【开始位置包括：结束位置不包括：步长默认1】4.序列相加：序列1 + 序列2：只能同类型：列表+列表，元组+元组5.序列乘法：序列*乘数:复制乘数遍6.检查某个元素是否在序列中：print（“科比”in nba）-&gt;True  not in:不在7.计算序列长度，最大值，最小值：len（） max（） min（）：数值类型</code></pre><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><pre><code>1.语法：[,,,,,]2.创建列表：list = 【，，，，，】  创建空列表：list = 【】  创建数值列表：数字组成的 list（range（2,21,2））  list（）：转换成列表  del():删除 3.访问列表元素  print  python【2】  python【1:3】 4.遍历列表     for item in 列表名：输出每个元素     for index，item in enumerate（列表名）：输出index，item        print（index+1，item） 5.添加元素     列表1.append（新元素）   列表1.insert（0，“新元素”）：指定位置   列表1.expend（添加的列表）：默认最后，添加一整个列表 6.修改元素：获取再赋值 7.删除 del li【2】：可以用负数        l1.remove（“值”） 8.列表统计计算     count（）：    语法：list.count(对象)    运用：统计出现次数    index（）    语法：同上    运用：第一次出现的位置    sum（）    语法：sum（列表[,start]）：可选值：统计结果加上    运用：total = sum（list，1000） 9.列表排序     1.sort（）    语法：list.sort(key = None,reverse = False)        key = str.lower:不区分大小写        reverse：默认降序   2.内置：sorted（）：原列表不改变顺序        语法：sorted(list,key = None,reverse = False)              reverse:默认升序 10.列表推导式  a.list1 = [random.randint(10，100)，for i in range（10）]   生成随机数列表   语法：list = [表达式 for var in range]   b.生成特定需求列表（后面是列表）   list = [表达式 for var in list]   c.提取列表中符合条件的组成新列表   语法：list = [表达式 for var in list if 条件] 11.二维列表使用     语法：list = [[],[],[],[]]</code></pre><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><h5 id="元组创建"><a href="#元组创建" class="headerlink" title="元组创建"></a>元组创建</h5><pre><code>truplename = (,,,)创建一个的时候再后面加上，号创建空元组：一样创建数值元组：一样</code></pre><h5 id="元组删除"><a href="#元组删除" class="headerlink" title="元组删除"></a>元组删除</h5><pre><code>del 元组名称</code></pre><h5 id="访问元组元素"><a href="#访问元组元素" class="headerlink" title="访问元组元素"></a>访问元组元素</h5><pre><code>print（）输出索引输出：元组名[1]切片输出：元组[1:3]for name in 元组：    print（name + “咖啡” end = “ ”）for index，item in enumerate（元组）</code></pre><h5 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h5><pre><code>1.不能对单个修改2.可以直接修改整个元组3.可以直接讲两个元组加起来4.单个元组要加，号</code></pre><h5 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h5><pre><code>1.随机生成：生成器对象，需要tuple转换2.访问过后生成器对象不存在了，转换为空</code></pre><h5 id="元组和列表的区别"><a href="#元组和列表的区别" class="headerlink" title="元组和列表的区别"></a>元组和列表的区别</h5><pre><code>1。元组不可变：不能添加删除，可以整体替换2，切片只能访问3，元组访问快4，可以作为字典键，列表不可以</code></pre><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><h5 id="键值对来组成"><a href="#键值对来组成" class="headerlink" title="键值对来组成"></a>键值对来组成</h5><pre><code>1.创建：word = {key1:值，，，，，}2.zip函数把列表转换成元组zip（list1，list2）返回zip对象，dict（）转换成字典3.dict{name：sign}：注意列表不能作为字典的键4.空的{}，dict（）5.dict = dict（name = '值'，，，，，）6.dict = dict.fromkeys(列表):只有名字的字典，值为none</code></pre><h5 id="删除字典"><a href="#删除字典" class="headerlink" title="删除字典"></a>删除字典</h5><pre><code>1.del 字典名2.字典名.clear()</code></pre><h5 id="键值对访问字典"><a href="#键值对访问字典" class="headerlink" title="键值对访问字典"></a>键值对访问字典</h5><pre><code>1.print：全部输出2.通过键访问值3.字典对象的get方法：    dict.get("key",[默认值])</code></pre><h5 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h5><pre><code>1.items方法：字典.items（）    for item in 字典.items（）：        print（item）2.也可以直接获得键和值 字典.key   字典.value</code></pre><h5 id="添加修改删除字典"><a href="#添加修改删除字典" class="headerlink" title="添加修改删除字典"></a>添加修改删除字典</h5><pre><code>1.添加:dict[key] = 值2.删除: del 字典[键]</code></pre><h5 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h5><pre><code>1.dict = {i:rangdom.randint(10,100) for i in range(1,5)}2.</code></pre><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><h5 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h5><pre><code>set集合：可变集合frozenset：不可变集合定义：不同对象的集合，不重复的元素字典和集合的区分：元素和键值对创建语法：{元素，，，，，，}集合：去重，顺序不定，不支持索引set（）：空集合set = set（）：也可以用来将其他的转换成集合</code></pre><h5 id="集合的添加和删除"><a href="#集合的添加和删除" class="headerlink" title="集合的添加和删除"></a>集合的添加和删除</h5><pre><code>集合名.add(不能是可迭代对象)集合.remove（删除元素）：一个集合.pop（无）：随机，返回删除的元素集合.clear():all</code></pre><h5 id="集合的交并补差"><a href="#集合的交并补差" class="headerlink" title="集合的交并补差"></a>集合的交并补差</h5><pre><code>&amp;：交|：并-：差</code></pre><h4 id="字符串编码转换"><a href="#字符串编码转换" class="headerlink" title="字符串编码转换"></a>字符串编码转换</h4><h5 id="encode-编码"><a href="#encode-编码" class="headerlink" title="encode:编码"></a>encode:编码</h5><pre><code>语法：str = str1.encode（GBK）:不会修改原字符串</code></pre><h5 id="decode：解码"><a href="#decode：解码" class="headerlink" title="decode：解码"></a>decode：解码</h5><pre><code>语法：str = str1.decode(GBK):什么编码什么解</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h5><pre><code>语法：+，不能把字符串和数值加起</code></pre><h5 id="计算长度"><a href="#计算长度" class="headerlink" title="计算长度"></a>计算长度</h5><pre><code>语法：len（字符串）：字符个数，不管中英文</code></pre><h5 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h5><pre><code>切片：string[stsrt:end:step]</code></pre><h5 id="分割合并字符串"><a href="#分割合并字符串" class="headerlink" title="分割合并字符串"></a>分割合并字符串</h5><pre><code>listname = str.split(分割符，分割次数)合并:语法：str = str.join(可迭代变量)  str = "@".join(list1)</code></pre><h5 id="检索字符串"><a href="#检索字符串" class="headerlink" title="检索字符串"></a>检索字符串</h5><pre><code>str.count(字符串，start，end):出现次数find（~）：是否存在，返回首次位置index（）：是否包含，不存在输出异常，返回第一次出现的位置starswith：以什么开始endswith：以什么结束</code></pre><h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><pre><code>lower（）:小写upper（）：大写</code></pre><h5 id="去除字符串的空格和特殊字符"><a href="#去除字符串的空格和特殊字符" class="headerlink" title="去除字符串的空格和特殊字符"></a>去除字符串的空格和特殊字符</h5><pre><code>1、strip：去除字符串两边空格。只会去除两侧，不会中间，可以指定去除啥2、lstrip：去除前面的字符3、rstrip：去除后面的</code></pre><h5 id="格式化字符串（后面来看）"><a href="#格式化字符串（后面来看）" class="headerlink" title="格式化字符串（后面来看）"></a>格式化字符串（后面来看）</h5><pre><code>%：-+0m.n格式化字符：%exp例如：%09d：9位数format：语法：str.format（参数）</code></pre><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><pre><code>1、匹配字符串的规则</code></pre><h5 id="行定位符"><a href="#行定位符" class="headerlink" title="行定位符"></a>行定位符</h5><pre><code>1、定位行：的开始和结束^:start $:end2、元字符：3、字符类：【aeiou】4、排除字符：^5、选择字符：|6、转义字符：\7、分组：（）</code></pre><h5 id="使用re模块匹配字符串"><a href="#使用re模块匹配字符串" class="headerlink" title="使用re模块匹配字符串"></a>使用re模块匹配字符串</h5><h6 id="匹配字符串"><a href="#匹配字符串" class="headerlink" title="匹配字符串"></a>匹配字符串</h6><pre><code>1、match（模式字符串，字符串，规则）：2、</code></pre><h3 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h3><h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><pre><code>语法：class 类名：（首字母大写）    '''帮助信息 '''    类体</code></pre><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><pre><code>语法：类名（可选参数）：没有init方法就不用参数</code></pre><h4 id="创建init（）方法"><a href="#创建init（）方法" class="headerlink" title="创建init（）方法"></a>创建<strong>init</strong>（）方法</h4><pre><code>意义：相当于构造方法：初始化，创建对象时自动使用语法：def __init__(self，，，):    print（）self:1.必须作为第一个参数2.相当于this指针3.写其他的也能输出，但不介意 构造方法：只能有一个</code></pre><h4 id="创建类的成员并访问"><a href="#创建类的成员并访问" class="headerlink" title="创建类的成员并访问"></a>创建类的成员并访问</h4><h5 id="创建实例方法并访问"><a href="#创建实例方法并访问" class="headerlink" title="创建实例方法并访问"></a>创建实例方法并访问</h5><pre><code>语法：def 名字（self（必须），参数列表）：      block方法名（参数列表）访问：对象.方法名（参数列表）默认值：参数后面加等号</code></pre><h5 id="创建数据成员并访问"><a href="#创建数据成员并访问" class="headerlink" title="创建数据成员并访问"></a>创建数据成员并访问</h5><h6 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h6><pre><code>定义：类中，方法体外语法：名字 = 值访问：init中：类名.类属性添加属性：类名.属性</code></pre><h6 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h6><pre><code>定义：方法中语法：def 名字（self）：            self.名字 =         self.名字 = 访问：self.名字   类外：对象.名字</code></pre><h5 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h5><pre><code>意义：语法：-：保护，类本身和子类可以访问，类外可以用对象访问      --：私有，类本身可以访问，对象不能访问，对象._类名+私有类型属性    --a--：系统</code></pre><h4 id="属性property"><a href="#属性property" class="headerlink" title="属性property"></a>属性property</h4><h5 id="创建用于计算的属性"><a href="#创建用于计算的属性" class="headerlink" title="创建用于计算的属性"></a>创建用于计算的属性</h5><pre><code>也就是装饰器：@property：转换成属性def 方法（self）：：可以修改block不能从新赋值</code></pre><h5 id="为属性添加安全保护机制"><a href="#为属性添加安全保护机制" class="headerlink" title="为属性添加安全保护机制"></a>为属性添加安全保护机制</h5><pre><code>装饰器：可以将私有属性设置为只读方法变装饰器可以更改：@show.setter：可以修改</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>class 类名（基类，可以多个）：'''help '''   类体</code></pre><p>   注意：如果不指定基类，默认object</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css字体和背景</title>
      <link href="/2020/043011637.html"/>
      <url>/2020/043011637.html</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-字体和背景"><a href="#CSS-字体和背景" class="headerlink" title="CSS-字体和背景"></a>CSS-字体和背景</h1><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code>    color: 颜色        font-size:字体大小        em：相当于当前元素的font-size        rm：相对于根元素的font-size        font-family：字体族            -serif：            -sans-size            -monospace；等宽                -指定字体类别                -可以设置多个：从第一个开始</code></pre><h2 id="图标字体"><a href="#图标字体" class="headerlink" title="图标字体"></a>图标字体</h2><pre><code>    用法：        - &lt;i class = "fas fa-bell"&gt;&lt;/i&gt;        后面fa-bell为图标名字；可以改颜色，大小，            -style=""里面设置  其他用法：    通过实体使用图标字体：&amp;#x图标的编码                        class = fas x        &lt;i class = "fas fa-bell"&gt;&lt;/i&gt;</code></pre><h2 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h2><h2 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h2><pre><code>行高：line.height        字体框：就是字体存在格子：设置font-size就是设置字体框大小        行高会在字体框的上下平均分配        设置行高和高一样，就是垂直居中        行间距等于行高-字体大小</code></pre><h2 id="字体的简写属性"><a href="#字体的简写属性" class="headerlink" title="字体的简写属性"></a>字体的简写属性</h2><pre><code>    font:设置所有属性                语法：字体大小/行高，字体族：必须写，最后两个                行高可以省略不写，默认值：            font-weight：字重：加粗                -可选值：                    -normal                    -bold            font-size：                -italic：斜体                -normal            font：时会覆盖上面的设置</code></pre><h2 id="文本的水平和垂直对齐"><a href="#文本的水平和垂直对齐" class="headerlink" title="文本的水平和垂直对齐"></a>文本的水平和垂直对齐</h2><pre><code>    text-align:文本的水平对齐                -可选值                   -left                   -right                   -center                   -justify:两端对齐            vertical:垂直对齐                -baseline:基线对齐                -top:顶部对齐                -bottom                -middle</code></pre><h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><pre><code>    text-decortion:        -none        -underline        -line-throught        -overline    white-space:设置空白处理        -normal        -nowrap:不换行        -pre：保留换行        -    text-overflow    overflow：        -elispsis：设置溢出省略号</code></pre><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><pre><code>设置背景图片            -可以同时设置背景图片和背景颜色            -如果背景图片大于元素：一部分无法显示            -如果背景图小：平铺            background-repead：用来设置背景重复方式                repead：默认值:xy方向重复                repead-x：                repead-y：                no-repead：不重复            background-position:设置背景图片的位置                -top，left，right，bottom，center九宫格            background-clip:设置边框范围                -border-box:默认背景出现在边框下面                -padding-box：背景不会出现在边框下面                -content-box：只出现在内容区            background-origin：背景图偏移位置                -padding-box：内边距上                -content-box：背景图片的偏移量从内容区计算                -border-box：边框上开始计算            background-size：设置背景图片大小                -两个值：只写一个自动                --cover：图片比例不变：铺满元素                -contain：比例不变，完整显示            background-attachment：设置图片移动                -srcoll：随元素移动                -fixed：不会随元素移动            注意：                -：size必须卸载position构面并用/隔开                -：origin要在clip的前面</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS-定位</title>
      <link href="/2020/043013442.html"/>
      <url>/2020/043013442.html</url>
      
        <content type="html"><![CDATA[<h1 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h1><h2 id="一、定位简介"><a href="#一、定位简介" class="headerlink" title="一、定位简介"></a>一、定位简介</h2><pre><code>定位：            -更加高级的布局手段            -通过定位可以将元素任意定位            -position属性设置定位                -可选值                    -static：元素静止：                    relative：开启相对定位：参照元素在文档流中的位置                    fixed：固定定位                    absolute：绝对定位                    sticky：粘滞定位            -相对定位：当元素的position属性值设定为relative                -不设置偏移量不会发生任何变化                -提升层级                -不会脱离文档流                -不改变属性            -偏移量：offset                -相当于margin这些                    -top                    -bottom                        -通常使用一个                    -left                    -right                        -通常使用一个</code></pre><h2 id="二、绝对定位"><a href="#二、绝对定位" class="headerlink" title="二、绝对定位"></a>二、绝对定位</h2><pre><code>绝对定位：positin：absolute                -绝对定位的特点                    -开启绝对定位后：如果不设置偏移量,元素位置不会发生变化                    -开启绝对定位后会从文档流中脱离                    -绝对定位会改变元素的性质：行内变成块，块的块高被内容撑开                    -会使元素提升一个层级                    -绝对定位元素相对于其包含块惊进行定位            包含块（containing block）                -正常：离当前元素最近的祖先元素                divdivdivdiv                divspanememspandiv：em的是div                -绝对定位的包含块：就是离他最近的开启了定位的祖先元素                    -如果都没有开启定位则：相对于根元素html：初始包含块</code></pre><h2 id="三、固定定位"><a href="#三、固定定位" class="headerlink" title="三、固定定位"></a>三、固定定位</h2><pre><code>固定定位：                -position：fixed                -也是一种绝对定位，大部分和绝对定位一样                -唯一不同：固定定位永远参照于浏览器的视口定位                -固定定位的元素不会随网页的滚动而移动</code></pre><h2 id="四、粘滞定位"><a href="#四、粘滞定位" class="headerlink" title="四、粘滞定位"></a>四、粘滞定位</h2><pre><code>粘滞定位                   -position：sticky                  - 和相对定位基本一样                  -在某一位置可以固定</code></pre><h2 id="五、绝对固定定位"><a href="#五、绝对固定定位" class="headerlink" title="五、绝对固定定位"></a>五、绝对固定定位</h2><pre><code>当我们开启绝对定位后                -水平方向布局等式需要加上left，fight两个值                    -当发生过度约束，9个值都没有auto，自动调整right满足                    -如果有auto调auto            可设置auto的值                -margin width left right            因为：left，right的值默认auto                等式 不满足，默认调整right，left            垂直方向布局的等式也必须要满足：</code></pre><h2 id="六、元素层级"><a href="#六、元素层级" class="headerlink" title="六、元素层级"></a>六、元素层级</h2><pre><code>z-index:设置层级                -值越大层级越高                -不写优先靠下的                -祖先元素的层级再高也不会盖住后代</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS—布局笔记</title>
      <link href="/2020/043011415.html"/>
      <url>/2020/043011415.html</url>
      
        <content type="html"><![CDATA[<h1 id="css布局"><a href="#css布局" class="headerlink" title="css布局"></a>css布局</h1><h2 id="一、文档流"><a href="#一、文档流" class="headerlink" title="一、文档流"></a>一、文档流</h2><pre><code>文档流（normal flow）            -网页是层叠的            -通过css可以给每一层设置样式            -用户只能看到最顶上一层            -这些层中最低下一层称为文档流            -我们所创建的元素默认都是在文档流中进行排列            -对于我们元素有两个状态                -在文档流中                -脱离文档流中            在文档流中有何特点                -块元素                    -块元素独占一行                    -默认宽度：父元素撑满                    -默认高度：内容撑满                -行内元素                    -不会独占一行                    -只占自身大小                    -一行中不能容纳所有：换行                    -行内元素的默认宽度：内容撑开</code></pre><h2 id="二、盒子模型"><a href="#二、盒子模型" class="headerlink" title="二、盒子模型"></a>二、盒子模型</h2><pre><code>    盒子模型        -box model        怎么摆放元素：            -css中将页面中的元素设置成了一个矩形盒子            -设置为矩形的盒子：布局就是摆放盒子            -怎么设置大小和位置：                -组成:                    -内容区（content）                    -边框（bonder）                    -内边距（padding）：内容区和边框的距离                    -外边距（margin）：决定位置；两个盒子间的距离</code></pre><h2 id="三、盒子模型-边框"><a href="#三、盒子模型-边框" class="headerlink" title="三、盒子模型-边框"></a>三、盒子模型-边框</h2><pre><code>    边框                -boder-width:默认值3px                    -四个值：顺时针                    -三个：左等于右                    -两个值：上下，左右                    -boder-top-width                        -top，right，left，bottom，  以下都有：                -boder-color：边框颜色                    -如果不写：默认指定color值                -boder-style：边框样式                    -soild： 实线                    -dotted：点状虚线                    -dashed：虚线                    -double：双线                    -不可不写：默认值是none                     boder简写形式：同时设定，没有顺序要求                    border: 10px orange solid;</code></pre><h2 id="四、盒子模型-内边距"><a href="#四、盒子模型-内边距" class="headerlink" title="四、盒子模型-内边距"></a>四、盒子模型-内边距</h2><pre><code>  内边距（padding）              -内容区和边框间的距离              -四个方向都有                  padding-top          -************************会影响到盒子的大小              -背景颜色会延伸到内边距上          盒子大小可见框：边框+内容+内边距</code></pre><h2 id="五、盒子模型-外边距"><a href="#五、盒子模型-外边距" class="headerlink" title="五、盒子模型-外边距"></a>五、盒子模型-外边距</h2><pre><code>   外边距（margin）            -不会影响可见框大小            -会影响盒子位置            -有四个方向        元素在页面中是按自左向右的顺序排列            -左上：会移动元素自身            -下右：移别人        可以设置负值：像相反方向移动        简写：margin：四个外边距        margin：影响盒子实际大小       </code></pre><h2 id="六、水平方向的布局"><a href="#六、水平方向的布局" class="headerlink" title="六、水平方向的布局"></a>六、水平方向的布局</h2><pre><code>    水平方向的布局：            -元素在其父元素中的水平布局               margin-left               border-left               padding-left               width               padding-right               border-right               margin-right            -一个元素在其父元素中必须满足：                从左到右加起来：外边距+内边距+内容+右部分=父元素内容区的宽度            不成立：过度约束：自动调整                -调整情况                    -如果这七个值中没有auto的情况：会调整margin-right满足            三个可以设置为auto；                -width                -margin-left                -margin-right                调整auto的值            水平居中：               实例：                  width：                  margin：auto</code></pre><h2 id="七、垂直方向的布局"><a href="#七、垂直方向的布局" class="headerlink" title="七、垂直方向的布局"></a>七、垂直方向的布局</h2><pre><code>      子元素大于父元素：撑破父元素：溢出        子元素在内容区中排列：            用overflow：设置处理溢出                -visable:显示溢出                -hidden：隐藏溢出                -scroll:生成滚动条，来查看完整的内容                -auto：根据需要生成滚动条            overflow-x：水平方向            overflow-y：垂直方向     </code></pre><h2 id="八、盒子模型外边距的折叠"><a href="#八、盒子模型外边距的折叠" class="headerlink" title="八、盒子模型外边距的折叠"></a>八、盒子模型外边距的折叠</h2><pre><code>    外边距的重叠：        -相邻的垂直外边距重叠：        -兄弟元素            -两者之间取较大值，两者都是正值            -一正一负：和            -两个负：两者取绝对值较大的        -兄弟元素之间外边距的重叠对于开发有利：不需要处理        -父子元素            -父子元素间的相邻外边距：子元素会传递给父元素            -父子外边距重叠会影响页面布局：必须处理       </code></pre><h2 id="九、行内元素的盒模型"><a href="#九、行内元素的盒模型" class="headerlink" title="九、行内元素的盒模型"></a>九、行内元素的盒模型</h2><pre><code>      行内元素            -display：元素显示模式                -可选值：                    -inline：设置为行内                    -block：设置为块元素                    -inline-block:行内块元素                        -既可以设置宽高，又不会独占一行:有缺点：想文字一样有间隔                    -table：设置为表格                    -none：不在页面中显示        visibility：设置显示状态              -visible：正常显示              -hidden：隐藏：占位置,none不占    </code></pre><h2 id="十、浏览器的默认样式"><a href="#十、浏览器的默认样式" class="headerlink" title="十、浏览器的默认样式"></a>十、浏览器的默认样式</h2><pre><code> 两个文件：normal，resert</code></pre><h2 id="十一、盒子大小"><a href="#十一、盒子大小" class="headerlink" title="十一、盒子大小"></a>十一、盒子大小</h2><pre><code>     默认情况下：可见框大小：内容+内边距+边框                box-sizing：设置盒子计算方式                    -可选值：                        content-box：高度和宽度设置内容区大小                        border-box：宽度高度设置盒子可见框大小                            三个加起来的大小</code></pre><h2 id="十二、圆角和轮廓"><a href="#十二、圆角和轮廓" class="headerlink" title="十二、圆角和轮廓"></a>十二、圆角和轮廓</h2><pre><code>  outline用来设置轮廓线            -轮廓不会影响可见框的大小，border会影响            -设置鼠标移入    box-shadow：用来设置元素的阴影效果：不会影响可见框大小            -默认和盒子一样大            -需要设置偏移量：默认偏移量是0            -第一个：左侧偏移值：水平位置            -第二个：右侧偏移值：垂直位置            -第三个：阴影模糊半径            -第四个：颜色            -可以设置负值           border-radius: ;        -设置圆角            -值为圆角半径            -指定四个角：顺时针：四个值            -三个值:对角一样            -两个：            -一个            -百分数：50%：圆形      </code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS笔记</title>
      <link href="/2020/043085.html"/>
      <url>/2020/043085.html</url>
      
        <content type="html"><![CDATA[<h1 id="css笔记"><a href="#css笔记" class="headerlink" title="css笔记"></a>css笔记</h1><h2 id="一、css3介绍"><a href="#一、css3介绍" class="headerlink" title="一、css3介绍"></a>一、css3介绍</h2><pre><code>    网页分成三个部分：        结构：html        表现：css        行为：js    css：        -层叠样式表：页面实际上是多层结构        -设置网页元素样式     -第一种方式（内联样式，行内样式）        -在便签内部通过style来设置元素样式，属性只能在开始标签写        -多以写多个        -font-size:字体大小</code></pre><h2 id="二、编写位置"><a href="#二、编写位置" class="headerlink" title="二、编写位置"></a>二、编写位置</h2><pre><code>    内联样式只能对一个标签产生影响        -当样式发生变化需要一个一个改    注意:开发时绝对不要用内联样式     第三种方式:外部样式(最佳实践)        -可以将css样式编写到一个外部css文件中        -然后通过link标签来引用外部文件,这样意味着只要想用样式网页都可以进行引用            -href:路径     -将样式编写到css文件中可以使用到浏览器的缓存机制从而加快网页加载速度</code></pre><h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><pre><code>    style标签内部不属于html    css基本语法:        -p:选择器:选择元素        {}:声明块:指定要为元素设置的样式;结尾为一个            -一个样式名对应样式值:用:连接</code></pre><h2 id="四、常用选择器"><a href="#四、常用选择器" class="headerlink" title="四、常用选择器"></a>四、常用选择器</h2><pre><code>    将所有的段落设置为红色(字体)        元素选择器            -标签名            h{}        id选择器:根据元素id属性值选中一个元素            -#id属性值{}            -设置两个id也可以但是不能这么做        列子:        class:是一个标签属性,和id类似,可以重复使用            -可以通过class分组            -.为class属性            -可以同时为一个元素指定多个class        通配选择器            -所有元素            语法:*</code></pre><h2 id="五、复合选择器"><a href="#五、复合选择器" class="headerlink" title="五、复合选择器"></a>五、复合选择器</h2><pre><code>  交集选择器:选中同时满足多个条件              -作用:同时选中多个元素              -选择器1.选择器2{}          注意:如果有元素选择器,那么必须元素选择器开头              选择器分组(并集选择器)        -作用:选择多个选择器对应的元素        -语法:选择器1,选择器2{}             #b1.p1,h1,span:选择id加元素          </code></pre><h2 id="六、关系选择器"><a href="#六、关系选择器" class="headerlink" title="六、关系选择器"></a>六、关系选择器</h2><pre><code>  为div直接包含的span这只一个字体颜色红色        （为div直接包含的span设置一个字体颜色）        ******子元素选择器            作用：选中指定父元素的指定子元素            语法：父元素&gt;子元素        ******后代元素选择器                作用：选中元素的后代元素                语法：祖先 后代                 兄弟元素选择器                -先择下一个兄弟                    -语法：前一个 + 下一个：紧挨着的，隔着一个也不行                -选择下边所有的兄弟：                    -语法：兄~弟        </code></pre><h2 id="七、属性选择器"><a href="#七、属性选择器" class="headerlink" title="七、属性选择器"></a>七、属性选择器</h2><pre><code>  属性选择器            -语法【属性名】:选择含有指定属性的元素            【属性名 = 属性值】            【属性名^=属性】：选择属性值以指定值开始的元素            【属性名$= 属性值】：结尾            【属性名*=属性值】：选择含有某值的元素          </code></pre><h2 id="八、伪类选择器"><a href="#八、伪类选择器" class="headerlink" title="八、伪类选择器"></a>八、伪类选择器</h2><pre><code>  伪类：不存在的类        -描述一个元素特殊状态的第一个子元素，被点击的元素，鼠标点击的元素        -伪类一般情况下：号开头            -:first-child第一个子元素            -:last-child最后一个子元素            -:nth-child（3）选中第3个子元素                特殊值：                    n：第n个，范围全部0-&amp;                    2n；偶数个                    2n+1：奇数                    odd：奇数                    even：偶数        -以上这些伪类都是根据所有子元素排序        ：first-of-type        ：last-of-type        ：nth-of-type           -只找相同类型    否定伪类：        ：not（）：            -将符合条件的元素去除          </code></pre><h2 id="九、a元素的伪类选择器"><a href="#九、a元素的伪类选择器" class="headerlink" title="九、a元素的伪类选择器"></a>九、a元素的伪类选择器</h2><pre><code>        link：没访问过的链接        visited:访问过            -隐私问题：visited只能改颜色             -只能超链接用上面两个        hover:鼠标移入        active：鼠标点击            </code></pre><h2 id="十、伪元素选择器"><a href="#十、伪元素选择器" class="headerlink" title="十、伪元素选择器"></a>十、伪元素选择器</h2><pre><code>  伪元素        -特殊不存在的元素（特殊位置）            伪元素：：开头            ::first—letter：第一个字母            ::first-line:第一行            ::selection:表示选中内容            ::before：起始位置            ::after：元素最后                -before/after结合content使用                -套框框           p::first-letter               {                   font-size: 50px;               }               p::first-line               {                   background-color: yellowgreen;               }               p::selection               {                   color: darkmagenta;               }               div::before               {                   content: 'abc';                   color: red;               }               div::after               {                   content: 'abc';                   color:green;               }</code></pre><h2 id="十一、样式继承"><a href="#十一、样式继承" class="headerlink" title="十一、样式继承"></a>十一、样式继承</h2><pre><code>    样式的继承：给一个标签设置的样式会继承给他的后代元素            -只发生在后代里            -为了方便开发，利用继承     注意：并不是所有的样式都会被继承            -比如：背景，布局相关的</code></pre><h2 id="十二、选择器的权重"><a href="#十二、选择器的权重" class="headerlink" title="十二、选择器的权重"></a>十二、选择器的权重</h2><pre><code>     选中同一个元素        -样式的冲突            -当我们通过不同的选择器选中相同的元素，并且为相同的样式设置不同的值，此时发生样式冲突        发生样式冲突:            优先级：                    内联样式                    id选择器                    类和伪类选择器                    元素选择器                    通配选择器：*                    继承:没有优先级        多个时；相加        分组选择器：单独计算，一个“，”一组            选择器的累加不会超过最大数量级：比如：类选择器不会大于id选择器        优先级一样时：自下而上        可以在某一个样式的后边添加：!important：最高优先级            -开发中慎用</code></pre><h2 id="十三、像素和百分比"><a href="#十三、像素和百分比" class="headerlink" title="十三、像素和百分比"></a>十三、像素和百分比</h2><pre><code>     长度单位：                像素                百分比：设置属性相当于父元素使用的百分比：这样父元素变，子元素也变                em:em是相对于元素的字体大小来计算的                    -1em = 1font-size                    -em会根据字体大小而改变                rem：rem相对于字体：root相对于根元素html的字体大小计算的</code></pre><h2 id="十四、RGB值"><a href="#十四、RGB值" class="headerlink" title="十四、RGB值"></a>十四、RGB值</h2><pre><code>    RGB:        -R        -G        —B    每一种颜色的范围0-255之间    也可以用百分数    语法：RGB（红，绿 ，蓝）    RGBA:        -A表示透明            -1表示完全不透明            0.5：半透明    十六进制的RGB值：        -语法:#红绿蓝        -浓度：00-ff        -如果颜色两位两位重复可以简写            #aabbcc--#abc    HSL,HSLA：        H：色相0-360        S：饱和度0-100%        L；亮度0-100%        都是写百分比的：必须写</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客已打包成apk</title>
      <link href="/2020/042835377.html"/>
      <url>/2020/042835377.html</url>
      
        <content type="html"><![CDATA[<p>博客已打包成apk<br>链接：<a href="https://pan.baidu.com/s/1NUq2-hf4oK2f3T1TgG6ckQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1NUq2-hf4oK2f3T1TgG6ckQ</a><br>提取码：reuw</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> VIP视频解析网站源码（放到coding就可用）</title>
      <link href="/2020/042718991.html"/>
      <url>/2020/042718991.html</url>
      
        <content type="html"><![CDATA[<h1 id="VIP视频解析网站（本地-coding可用）"><a href="#VIP视频解析网站（本地-coding可用）" class="headerlink" title="VIP视频解析网站（本地+coding可用）"></a>VIP视频解析网站（本地+coding可用）</h1><p>体验连接<a href="http://cszar4.coding-pages.com" target="_blank" rel="noopener">VIP视频解析</a><br>不建议手机观看，因为接口不是我自己的所以广告我拦不住</p><p><img src="https://s1.ax1x.com/2020/04/27/JfKBTI.png" alt="JfKBTI.png"></p><p>链接：<a href="https://pan.baidu.com/s/1H-en7yaGBvnsPZqHISPHlA" target="_blank" rel="noopener">https://pan.baidu.com/s/1H-en7yaGBvnsPZqHISPHlA</a><br>提取码：6h53</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VIP </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬取网页图片</title>
      <link href="/2020/042463275.html"/>
      <url>/2020/042463275.html</url>
      
        <content type="html"><![CDATA[<h1 id="python爬取网页图片源代码"><a href="#python爬取网页图片源代码" class="headerlink" title="python爬取网页图片源代码"></a>python爬取网页图片源代码</h1><pre><code>import requestsfrom bs4 import BeautifulSoupurl = "    "#发送源代码response = requests.get(url)#response=200:没毛病# print(response)#指定编码集response.encoding = 'utf-8'#获取源码# print(response.text)#把源代码交给beautifulmain_page = BeautifulSoup(response.text,"html.parser")#find：找# 1.find(标签，attrs={属性，值})：找一个# 2.find_all（标签，attrs={属性，值}）：找一堆alist = main_page.find("div",attrs={"class":"TypeList"}).find_all("a",attrs={"class":"TypeBigPics"})for a in alist:    href = a.get("href")    child_resp = requests.get(href) # 请求到子页面    #设置字符集    child_resp.encoding = "utf-8"    child_page = BeautifulSoup(child_resp.text,"html.parser") # 子页面提取内容    img = child_page.find("div",attrs={"id":"ArticleId8"}).find("img")    # print(img.get("src")) #拿到路径    title = child_page.find('div',attrs={"class":"ArticleTitle"}).text    #下载图片    f = open("%s.jpg" % title, mode='wb')    f.write(requests.get(img.get("src")).content)    print(1)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章编辑后台搭建</title>
      <link href="/2020/042423408.html"/>
      <url>/2020/042423408.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo博客后台搭建"><a href="#Hexo博客后台搭建" class="headerlink" title="Hexo博客后台搭建"></a>Hexo博客后台搭建</h1><iframe frameborder="no" bordered="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=28208212&amp;auto=1&amp;height=66"></iframe><h2 id="一、插件介绍"><a href="#一、插件介绍" class="headerlink" title="一、插件介绍"></a>一、插件介绍</h2><pre><code> hexo-admin 是一个Hexo博客引擎的管理用户界面插件。这个插件最初是作为本地编辑器设计的，在本地运行hexo使用hexo-admin编写文章，然后通过hexo g或hexo d（hexo g是本地渲染，hexo d是将渲染的静态页面发布到GitHub）将生成的静态页面发布到GitHub等静态服务器。如果你使用的是非静态托管服务器，比如自己买的主机搭建的hexo，那么一定要设置hexo-admin 的密码，否则谁都可以编辑你的文章。</code></pre><h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><p><img src="https://s1.ax1x.com/2020/04/24/JDZBTI.png" alt="JDZBTI.png"></p><p><img src="https://s1.ax1x.com/2020/04/24/JDeicD.png" alt="JDeicD.png"></p><h2 id="三、插件安装"><a href="#三、插件安装" class="headerlink" title="三、插件安装"></a>三、插件安装</h2><p>1.首先进入hexo创建的博客项目的根目录下，执行</p><pre><code>npm install --save hexo-admin</code></pre><p>2.运行下列命令启动hexo-admin </p><pre><code>hexo server -d</code></pre><p>3.打开<code>http://localhost:4000/admin/</code>就可以访问到hexo-admin管理页面了。</p><p><img src="https://s1.ax1x.com/2020/04/24/JDZBTI.png" alt="JDZBTI.png"></p><h2 id="四、密码保护"><a href="#四、密码保护" class="headerlink" title="四、密码保护"></a>四、密码保护</h2><p>打开<code>setting</code>，点击<code>Setup authentification here</code>输入用户名，密码，密钥，<code>设置完后下面会自动生成配置文件</code>，复制加在hexo根目录下的_config.yml中：</p><pre><code>admin:  username: myfavoritename  password_hash: be121740bf988b2225a313fa1f107ca1  secret: a secret something</code></pre><p><img src="https://s1.ax1x.com/2020/04/24/JDm9Vs.png" alt="JDm9Vs.png"></p><p>重启<code>hexo</code>，就可以看到登录页面了</p><h2 id="五、发布文章"><a href="#五、发布文章" class="headerlink" title="五、发布文章"></a>五、发布文章</h2><p><img src="https://s1.ax1x.com/2020/04/24/JDQDKK.png" alt="JDQDKK.png"><br>1、进入后台之后点击<code>Deploy</code>，里面的<code>Deploy</code>按钮是用来执行发布脚本的，所以我们先在博客<code>根目录</code>下新建<code>hexo-pubish.bat</code>(名字任意后缀<code>bat</code>)文件</p><p><img src="https://s1.ax1x.com/2020/04/24/JDmuZ9.png" alt="JDmuZ9.png"></p><p>然后填入如下代码</p><pre><code>hexo g -d</code></pre><p>然后在_config.yml中的admin下添加<code>deployCommand: 'hexo-pubish.bat'</code>(和之前创建的文件名相同)</p><pre><code>admin:  username: myfavoritename  password_hash: be121740bf988b2225a313fa1f107ca1  secret: a secret something  deployCommand: 'hexo-pubish.bat'</code></pre><p>设置发布执行的脚本，点击<code>Deploy</code>就会执行这个命令并提交到GitHub上。</p><p><img src="https://s1.ax1x.com/2020/04/24/JDnzAs.png" alt="JDnzAs.png"></p><p>开始提交：<br><img src="https://s1.ax1x.com/2020/04/24/JDKZM8.png" alt="JDKZM8.png"></p><p>成功如下：<br><img src="https://s1.ax1x.com/2020/04/24/JDKDRx.png" alt="JDKDRx.png"></p><h2 id="六、其他建议：添加一键本地运行"><a href="#六、其他建议：添加一键本地运行" class="headerlink" title="六、其他建议：添加一键本地运行"></a>六、其他建议：添加一键本地运行</h2><p>根目录下新建文件<code>hexo-s.bat</code><br><img src="https://s1.ax1x.com/2020/04/24/JDuljO.png" alt="JDuljO.png"></p><p>输入如下代码：</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s </code></pre><p>这样双击<code>hexo-s.bat</code>就可以直接本地查看了，很方便<br><img src="https://s1.ax1x.com/2020/04/24/JDuIrF.png" alt="JDuIrF.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python操作数据库</title>
      <link href="/2020/04233337.html"/>
      <url>/2020/04233337.html</url>
      
        <content type="html"><![CDATA[<h1 id="python操作数据库"><a href="#python操作数据库" class="headerlink" title="python操作数据库"></a>python操作数据库</h1><p><a href="https://imgchr.com/i/tVaisf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/28/tVaisf.jpg" alt="tVaisf.jpg"></a></p><h2 id="序章：mysql安装配置"><a href="#序章：mysql安装配置" class="headerlink" title="序章：mysql安装配置"></a>序章：mysql安装配置</h2><p><a href="https://www.jianshu.com/p/647a596cb251" target="_blank" rel="noopener">https://www.jianshu.com/p/647a596cb251</a></p><p><a href="https://www.cnblogs.com/winton-nfs/p/11524007.html" target="_blank" rel="noopener">https://www.cnblogs.com/winton-nfs/p/11524007.html</a></p><h2 id="第一章：为什么要数据库-gt-数据量大-方便管理"><a href="#第一章：为什么要数据库-gt-数据量大-方便管理" class="headerlink" title="第一章：为什么要数据库->数据量大,方便管理"></a>第一章：为什么要数据库-&gt;数据量大,方便管理</h2><pre><code>    sqlite:嵌入式数据库,数据库就是一个文件    mysql:开源</code></pre><h3 id="第一节-数据库编程接口"><a href="#第一节-数据库编程接口" class="headerlink" title="第一节:数据库编程接口"></a>第一节:数据库编程接口</h3><pre><code>    OB_API:数据库标准规范：PEP249:API规范</code></pre><h4 id="1-连接对象：connect-函数创建"><a href="#1-连接对象：connect-函数创建" class="headerlink" title="1.连接对象：connect()函数创建"></a>1.连接对象：connect()函数创建</h4><pre><code>    参数：        dsn：数据源名称        user：用户名        password：用户密码        host：主机名        datebase：数据库名</code></pre><h5 id="1-connect的常用方法"><a href="#1-connect的常用方法" class="headerlink" title="1.connect的常用方法"></a>1.connect的常用方法</h5><pre><code>    方法：    cursor():获取游标对象    commit():提交事务    rollback():回滚事务    close():关闭数据库连接</code></pre><h5 id="2-事务：转钱失败-回滚"><a href="#2-事务：转钱失败-回滚" class="headerlink" title="2.事务：转钱失败-回滚"></a>2.事务：转钱失败-回滚</h5><h4 id="2-游标对象cursor"><a href="#2-游标对象cursor" class="headerlink" title="2.游标对象cursor"></a>2.游标对象cursor</h4><pre><code>    方法：    callproc：调用存储过程    close：关闭    execute：执行数据库操作    executemany：批量执行    fechone：获取查询结果下一条    fechmany：获取指定数量    fechall：获取结构集的所有记录    nextset：跳至下一个结果集</code></pre><h4 id="3-先关闭cur再关闭connect"><a href="#3-先关闭cur再关闭connect" class="headerlink" title="3.先关闭cur再关闭connect"></a>3.先关闭cur再关闭connect</h4><h3 id="第二节：创建数据库文件"><a href="#第二节：创建数据库文件" class="headerlink" title="第二节：创建数据库文件"></a>第二节：创建数据库文件</h3><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><pre><code>#导入PyMySQL模块import pymysql#localhost是固定的host=localhost：不是连接名字#调用connect函数生产connection连接对象#不能换顺序，下面的参数顺序db = pymysql.connect(host = 'localhost',user= 'root',password = 'root',database = 'text')#调用cursor方法创建cursor对象cursor = db.cursor()#执行SQL语句cursor.execute('select version()')data = cursor.fetchone()print(data)#关闭连接cursor.close()db.close()</code></pre><h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><pre><code>#导入PyMySQL模块import pymysql#localhost是固定的host=localhost：不是连接名字#调用connect函数生产connection连接对象#不能换顺序，下面的参数顺序db = pymysql.connect(host = 'localhost',user= 'root',password = 'root',database = 'text')#调用cursor方法创建cursor对象cursor = db.cursor()cursor.execute('drop table if exists books')#执行SQL语句sql = """CREATE TABLE books(    id int(8) NOT NULL AUTO_INCREMENT,    name varchar(50) NOT NULL,    category varchar(50) NOT NULL,    price decimal(10,2) DEFAULT NULL,    publish_time date DEFAULT NULL,    PRIMARY KEY(id))ENGINE = MYISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;"""cursor.execute(sql)#关闭连接cursor.close()db.close()</code></pre><h4 id="操作数据表"><a href="#操作数据表" class="headerlink" title="操作数据表"></a>操作数据表</h4><pre><code>#导入PyMySQL模块import pymysql#localhost是固定的host=localhost：不是连接名字#调用connect函数生产connection连接对象#不能换顺序，下面的参数顺序db = pymysql.connect(host = 'localhost',user= 'root',password = 'root',database = 'text',charset = 'utf8')#调用cursor方法创建cursor对象cursor = db.cursor()#执行SQL语句data = [('lingisme9','python','79.89','2020-12-12'),('lingisme9','python','79.89','2020-12-12'),('lingisme9','python','79.89','2020-12-12'),('lingisme9','python','79.89','2020-12-12')]try:    sql = "insert into books(name,category,price,publish_time) values (%s,%s,%s,%s)"    cursor.executemany(sql,data)    db.commit()except:    db.rollback()#关闭连接cursor.close()db.close()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo框架matery主题+github搭建个人博客</title>
      <link href="/2020/042219999.html"/>
      <url>/2020/042219999.html</url>
      
        <content type="html"><![CDATA[<h1 id="hexo框架-github搭建个人博客"><a href="#hexo框架-github搭建个人博客" class="headerlink" title="hexo框架+github搭建个人博客"></a>hexo框架+github搭建个人博客</h1><p><img src="https://s1.ax1x.com/2020/04/22/JN7gcq.jpg" alt="坏蛋先生"></p><h2 id="一、hexo简介"><a href="#一、hexo简介" class="headerlink" title="一、hexo简介"></a>一、hexo简介</h2><p>1、Hexo 是一个快速、简洁且高效的博客框架。</p><p>2、官网入口及api：<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a></p><p>3、Hexo 是基于nodejs的框架</p><p>4、可以配置在很多地方：github、gitee、coding等</p><h2 id="二、nodejs安装配置"><a href="#二、nodejs安装配置" class="headerlink" title="二、nodejs安装配置"></a>二、nodejs安装配置</h2><p>1、Hexo是基于nodeJS环境的静态博客，需要用到nodejs中的npm安装（npm安装nodejs时自动安装）</p><p>2、下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a>推荐LTS (说明：LTS为长期支持版，Current为当前最新版)</p><p>3、安装步骤：下载好msi文件,一路next</p><p>4、验证安装:<code>win + r</code>输入 <code>cmd</code> 进入命令行窗口输入如下命令出现版本号安装成功：<br>    <code>$ node -v</code></p><h2 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h2><p>1、<code>你的用户名.github.io</code>   比如: 如果你的github用户名是<code>test</code>，那么你就新建<code>test.github.io的仓库</code>（必须是你的用户名）</p><p>2、新建<code>readerme</code>文件，什么都不用添加</p><p>3、访问：<code>你的用户名.github.io</code>（不出现404就行）</p><h2 id="三、git安装配置"><a href="#三、git安装配置" class="headerlink" title="三、git安装配置"></a>三、git安装配置</h2><p>1、<a href="https://git-scm.com/" target="_blank" rel="noopener">下载git</a></p><p>2、安装git（除图片这一步选第二个其他都next）<br>3、因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识，用户和邮箱为你github注册的账号和邮箱右键打开git-bash.exe<br><code>$ git config --global user.name "你的github用户名"</code><br><code>$ git config --global user.email "你注册github的邮箱"</code><br><img src="https://s1.ax1x.com/2020/04/22/JNHwx1.png" alt=""></p><p>4、为Github账户设置<code>SSH key</code>(ssh key是加密传输)<br>    首先检查是否生成了秘钥,如果没有生成，那么通过如下命令：<br>    <code>$ ssh-keygen -t rsa -C “你的github注册邮箱”</code>        </p><pre><code>1.是路径确认，直接按回车存默认路径即可2.直接回车键，这里我们不使用密码进行登录, 用密码太麻烦3.直接回车键</code></pre><p><img src="https://s1.ax1x.com/2020/04/22/JNHqiQ.png" alt=""></p><p>5、可以打开你的电脑<code>C:\Users\Administrator.ssh</code>里面找到，生成成功后，可以查看 <code>id_rsa.pub</code> 公钥文件</p><p>6、为github账号配置<code>ssh_key</code>：setting—&gt;SSH and GPG keys<br> <img src="https://s1.ax1x.com/2020/04/22/JNbKoD.png" alt=""></p><p>7、验证是否成功输入如下代码：<br>    <code>$ ssh -T git@github.com</code><br>正常情况下会出现(有警告可以不用管)：<br>    <code>Hi Your Name! You've successfully authenticated, but GitHub does not provide shell access.</code></p><h2 id="四、hexo安装"><a href="#四、hexo安装" class="headerlink" title="四、hexo安装"></a>四、hexo安装</h2><h3 id="这里介绍两种方法安装："><a href="#这里介绍两种方法安装：" class="headerlink" title="这里介绍两种方法安装："></a>这里介绍两种方法安装：</h3><h4 id="1、正常安装"><a href="#1、正常安装" class="headerlink" title="1、正常安装"></a>1、正常安装</h4><p>(1)右键打开<code>git bash here</code>输入如下代码：<br>    <code>$ npm install -g hexo-cli</code><br>如下成功：<br><img src="https://s1.ax1x.com/2020/04/22/JNqxET.png" alt=""><br>(2)查看版本信息输入如下代码：<br>    <code>$ hexo -v</code><br><img src="https://s1.ax1x.com/2020/04/22/JNLM2d.jpg" alt=""><br>(3)初始化hexo程序任意你想要保存博客文件的位置(推荐桌面,文件名随意)输入代码：<br>    <code>$ hexo init myblog</code></p><p>(4)进入<code>myblog</code>查看文件目录</p><p>** node_modules: 依赖包<br>** scaffolds：生成文章的一些模板<br>** source：用来存放你的文章<br>** themes：主题<br>** _config.yml: 博客的配置文件<br>** package.json：项目所需模块项目的配置信息</p><p><img src="https://s1.ax1x.com/2020/04/22/JNLYa8.jpg" alt=""><br>(5)打开hexo,本地查看，文件夹中会出现public的静态博客文件夹<br>a.输入如下命令生成public静态网页文件夹<br><code>$ hexo g</code></p><p>b.输入如下命令，本地查看（在浏览器中输入localhost：4000查看）<br><code>$ hexo s</code> </p><h4 id="2、hexo-init命令无法正常执行安装"><a href="#2、hexo-init命令无法正常执行安装" class="headerlink" title="2、hexo init命令无法正常执行安装"></a>2、<code>hexo init</code>命令无法正常执行安装</h4><p>(1)<a href="https://pan.baidu.com/s/1uaabyjR2ZdnmfjLu1QIBQg" target="_blank" rel="noopener">下载hexo基本文件 提取码：fn26</a></p><pre><code>_config.yml package.json scaffolds/ source/ themes/</code></pre><p>(2)安装依赖<br><code>$ npm install</code><br><code>$ npm install hexo-deployer-git --save  // 文章部署到 git 的模块</code></p><p>(3)输入如下命令生成public文件<br><code>$ hexo g</code></p><p>(4)输入如下命令本地查看<br><code>hexo s</code></p><h2 id="五、测试发布原生主题到github"><a href="#五、测试发布原生主题到github" class="headerlink" title="五、测试发布原生主题到github"></a>五、测试发布原生主题到github</h2><h3 id="1、修改你的根目录-config-yml-配置文件如下："><a href="#1、修改你的根目录-config-yml-配置文件如下：" class="headerlink" title="1、修改你的根目录 _config.yml 配置文件如下："></a>1、修改你的根目录 _config.yml 配置文件如下：</h3><pre><code># 注意是git开头的仓库地址# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.com:flyoob/flyoob.github.io.git  branch: master</code></pre><p>如何获取仓库地址<br><img src="https://s1.ax1x.com/2020/04/22/JUFycV.png" alt=""><br><img src="https://s1.ax1x.com/2020/04/22/JUFqBD.png" alt=""></p><h3 id="2、修改url：你的github用户名-github-io"><a href="#2、修改url：你的github用户名-github-io" class="headerlink" title="2、修改url：你的github用户名.github.io"></a>2、修改url：<code>你的github用户名.github.io</code></h3><p><img src="https://s1.ax1x.com/2020/04/22/JUFESx.png" alt="">也可以是你自己绑定的域名</p><h3 id="3、部署"><a href="#3、部署" class="headerlink" title="3、部署"></a>3、部署</h3><pre><code>hexo clean   // 清除缓存 网页正常情况下可以忽略此条命令hexo g       // 生成静态网页hexo d       // 开始部署</code></pre><h3 id="2、访问：你的用户名-github-io查看"><a href="#2、访问：你的用户名-github-io查看" class="headerlink" title="2、访问：你的用户名.github.io查看"></a>2、访问：<code>你的用户名.github.io</code>查看</h3><h2 id="六、下载matery主题"><a href="#六、下载matery主题" class="headerlink" title="六、下载matery主题"></a>六、下载matery主题</h2><h4 id="matery"><a href="#matery" class="headerlink" title="matery"></a><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">matery</a></h4><h2 id="七、配置matery主题"><a href="#七、配置matery主题" class="headerlink" title="七、配置matery主题"></a>七、配置matery主题</h2><h3 id="1-解压缩后，将hexo-theme-matery的文件夹复制到你-Hexo-的themes文件夹中即可。"><a href="#1-解压缩后，将hexo-theme-matery的文件夹复制到你-Hexo-的themes文件夹中即可。" class="headerlink" title="(1) 解压缩后，将hexo-theme-matery的文件夹复制到你 Hexo 的themes文件夹中即可。"></a>(1) 解压缩后，将<code>hexo-theme-matery</code>的文件夹复制到你 <code>Hexo</code> 的<code>themes</code>文件夹中即可。</h3><h3 id="2-切换主题"><a href="#2-切换主题" class="headerlink" title="(2) 切换主题"></a>(2) 切换主题</h3><pre><code>    修改 `Hexo `根目录下的` _config.yml `的 `theme `的值：`theme: hexo-theme-matery`</code></pre><h3 id="3-config-yml文件的其它修改建议"><a href="#3-config-yml文件的其它修改建议" class="headerlink" title="(3)_config.yml文件的其它修改建议:"></a>(3)<code>_config.yml</code>文件的其它修改建议:</h3><pre><code>请修改 _config.yml 的 url 的值为你的网站主 `URL（如：http://xxx.github.io）`。建议修改两个 `per_page `的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。如果你是中文用户，则建议修改 language 的值为` zh-CN`</code></pre><h3 id="4-新建分类-categories-页-注意页面上的分类不用你自己写，而是你在写文章时给文章写，matery会自己生成分类、标签"><a href="#4-新建分类-categories-页-注意页面上的分类不用你自己写，而是你在写文章时给文章写，matery会自己生成分类、标签" class="headerlink" title="(4)新建分类 categories 页(注意页面上的分类不用你自己写，而是你在写文章时给文章写，matery会自己生成分类、标签)"></a>(4)新建分类 <code>categories</code> 页(<code>注意页面上的分类不用你自己写，而是你在写文章时给文章写，matery会自己生成分类、标签</code>)</h3><p><code>categories</code>页是用来展示所有分类的页面，如果在你的博客 <code>source</code>目录下还没有 <code>categories/index.md</code>文件，那么你就需要新建一个，命令如下：<br><code>hexo new page "categories"</code><br>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>至少需要以下内容：</p><pre><code>---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---</code></pre><h3 id="5-新建标签-tags-页"><a href="#5-新建标签-tags-页" class="headerlink" title="(5)新建标签 tags 页"></a>(5)新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code>目录下还没有<code>tags/index.md</code>文件，那么你就需要新建一个，命令如下：<br><code>hexo new page "tags"</code><br>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre><code>---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---</code></pre><h3 id="6-新建关于我-about-页"><a href="#6-新建关于我-about-页" class="headerlink" title="(6)新建关于我 about 页"></a>(6)新建关于我 <code>about</code> 页</h3><p>about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 <code>source</code>目录下还没有<code>about/index.md</code>文件，那么你就需要新建一个，命令如下：<br><code>hexo new page "about"</code><br>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre><code>---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"---</code></pre><h3 id="7-新建友情连接-friends页（可选的）"><a href="#7-新建友情连接-friends页（可选的）" class="headerlink" title="(7)新建友情连接 friends页（可选的）"></a>(7)新建友情连接 <code>friends</code>页（可选的）</h3><p><code>friends</code> 页是用来展示友情连接信息的页面，如果在你的博客 source 目录下还没有<code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：<br><code>hexo new page "friends"</code><br>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>至少需要以下内容：</p><pre><code>---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"---</code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code>目录，在 <code>_data</code>目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre><code>[{    "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg",    "name": "码酱",    "introduction": "我不是大佬，只是在追寻大佬的脚步",    "url": "http://luokangyuan.com/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/4027734.jpeg",    "name": "闪烁之狐",    "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬",    "url": "https://blinkfox.github.io/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/avatar.jpg",    "name": "ja_rome",    "introduction": "平凡的脚步也可以走出伟大的行程",    "url": "ttps://me.csdn.net/jlh912008548",    "title": "前去学习"}]</code></pre><h3 id="8-代码高亮"><a href="#8-代码高亮" class="headerlink" title="(8)代码高亮"></a>(8)代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下：<br><code>npm i -S hexo-prism-plugin</code><br>然后，修改 <code>Hexo</code>根目录下 <code>_config.yml</code> 文件中<code>highlight.enable</code> 的值为 <code>false</code>，并新增<code>prism</code> 插件相关的配置，主要配置如下：</p><pre><code>highlight:  enable: falseprism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:</code></pre><h3 id="9-搜索"><a href="#9-搜索" class="headerlink" title="(9)搜索"></a>(9)搜索</h3><p>本主题中还使用到了 <code>hexo-generator-search</code> 的 <code>Hex</code>o 插件来做内容搜索，安装命令如下：<br><code>npm install hexo-generator-search --save</code><br>在 <code>Hexo</code>根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code>search:  path: search.xml  field: post</code></pre><h3 id="10-中文链接转拼音（可选的）"><a href="#10-中文链接转拼音（可选的）" class="headerlink" title="(10)中文链接转拼音（可选的）"></a>(10)中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用<code>hexo-permalink-pinyin Hexo</code>插件使在生成文章时生成中文拼音的永久链接。<br>安装命令如下：<br><code>npm i hexo-permalink-pinyin --save</code><br>在 <code>Hexo</code>根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre><code>permalink_pinyin:  enable: true  separator: '-' # default: '-'</code></pre><h3 id="11-文章字数统计插件（可选的）"><a href="#11-文章字数统计插件（可选的）" class="headerlink" title="(11)文章字数统计插件（可选的）"></a>(11)文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <code>hexo-wordcount</code>插件。<br>安装命令如下：<br><code>npm i --save hexo-wordcount</code><br>然后只需在本主题下的 <code>_config.yml</code>文件中，激活以下配置项即可：</p><pre><code>wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true</code></pre><h3 id="12-添加-RSS-订阅支持（可选的）"><a href="#12-添加-RSS-订阅支持（可选的）" class="headerlink" title="(12)添加 RSS 订阅支持（可选的）"></a>(12)添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <code>hexo-generator-feed</code> 的 <code>Hexo</code> 插件来做<code>RSS</code>，安装命令如下：<br><code>npm install hexo-generator-feed --save</code><br>在<code>Hexo</code>根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code>feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date</code></pre><p>执行<code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code>文件，说明你已经安装成功了。</p><h3 id="13-修改社交链接-主题中本来就有不用复制粘贴，源代码中修改即可"><a href="#13-修改社交链接-主题中本来就有不用复制粘贴，源代码中修改即可" class="headerlink" title="(13)修改社交链接(主题中本来就有不用复制粘贴，源代码中修改即可)"></a>(13)修改社交链接(<code>主题中本来就有不用复制粘贴，源代码中修改即可</code>)</h3><p>在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre><code>&lt;a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"&gt;    &lt;i class="fa fa-github"&gt;&lt;/i&gt;&lt;/a&gt;</code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在<code>Font Awesome</code>中搜索找到。以下是常用社交图标的标识，供你参考：</p><pre><code>    Facebook: fa-facebook    Twitter: fa-twitter    Google-plus: fa-google-plus    Linkedin: fa-linkedin    Tumblr: fa-tumblr    Medium: fa-medium    Slack: fa-slack    新浪微博: fa-weibo    微信: fa-wechat    QQ: fa-qq    注意: 本主题中使用的 Font Awesome 版本为 4.7.0。</code></pre><h3 id="14-修改打赏的二维码图片"><a href="#14-修改打赏的二维码图片" class="headerlink" title="(14)修改打赏的二维码图片"></a>(14)修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="15-配置音乐播放器（可选的）"><a href="#15-配置音乐播放器（可选的）" class="headerlink" title="(15)配置音乐播放器（可选的）"></a>(15)配置音乐播放器（可选的）</h3><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。</p><p>首先，在你的博客 <code>source</code> 目录下的 <code>_data</code> 目录（没有的话就新建一个）中新建 <code>musics.json</code> 文件，文件内容如下所示：</p><pre><code>[{    "name": "五月雨变奏电音",    "artist": "AnimeVibe",    "url": "http://xxx.com/music1.mp3",    "cover": "http://xxx.com/music-cover1.png"}, {    "name": "Take me hand",    "artist": "DAISHI DANCE,Cecile Corbel",    "url": "/medias/music/music2.mp3",    "cover": "/medias/music/cover2.png"}, {    "name": "Shape of You",    "artist": "J.Fla",    "url": "http://xxx.com/music3.mp3",    "cover": "http://xxx.com/music-cover3.png"}]</code></pre><p>注：以上 <code>JSON</code>中的属性：<code>name、artist、url、cover</code> 分别表示音乐的名称、作者、音乐文件地址、音乐封面。<br>然后，在主题的 <code>_config.yml</code>配置文件中激活配置即可：</p><pre><code># 是否在首页显示音乐.music:  enable: true  showTitle: false  title: 听听音乐  fixed: false # 是否开启吸底模式  autoplay: false # 是否自动播放  theme: '#42b983'  loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'list' # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: false # 列表默认折叠  listMaxHeight: # 列表最大高度</code></pre><h3 id="16-文章-Front-matter介绍-阅读文章时显示的信息"><a href="#16-文章-Front-matter介绍-阅读文章时显示的信息" class="headerlink" title="(16)文章 Front-matter介绍(阅读文章时显示的信息)"></a>(16)文章 <code>Front-matter</code>介绍(阅读文章时显示的信息)</h3><pre><code>---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h2 id="八、优化matery主题"><a href="#八、优化matery主题" class="headerlink" title="八、优化matery主题"></a>八、优化matery主题</h2><h3 id="1-修改主题颜色"><a href="#1-修改主题颜色" class="headerlink" title="(1)修改主题颜色"></a>(1)修改主题颜色</h3><p>在主题文件的<code>/source/css/matery.css</code>文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre><code>/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow {   /* 动态切换背景颜色. */}@keyframes rainbow {    /* 动态切换背景颜色. */}</code></pre><h3 id="2-修改-banner图和文章特色图-只要名字命名一样就行，图过大加载慢，图小不清晰图片批量压缩（密码：yvb5）"><a href="#2-修改-banner图和文章特色图-只要名字命名一样就行，图过大加载慢，图小不清晰图片批量压缩（密码：yvb5）" class="headerlink" title="(2)修改 banner图和文章特色图(只要名字命名一样就行，图过大加载慢，图小不清晰图片批量压缩（密码：yvb5）)"></a>(2)修改 <code>banner</code>图和文章特色图(只要名字命名一样就行，图过大加载慢，图小不清晰<a href="https://pan.baidu.com/s/1DlxWnHm5GLiopsJ21wkKyg" target="_blank" rel="noopener">图片批量压缩（密码：yvb5）</a>)</h3><p>你可以直接在 <code>/source/medias/banner</code>文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，</p><p><code>banner</code>切换的代码位置在 /<code>layout/_partial/bg-cover-content.ejs</code>文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><p><code>$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)');</code></p><p>在<code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。</p><h3 id="3-添加emoji表情支持（可选的）"><a href="#3-添加emoji表情支持（可选的）" class="headerlink" title="(3)添加emoji表情支持（可选的）"></a>(3)添加emoji表情支持（可选的）</h3><p>本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下：<br><code>npm install hexo-filter-github-emojis --save</code><br>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><pre><code>githubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:</code></pre><h3 id="4-给文章添加valine评论功能"><a href="#4-给文章添加valine评论功能" class="headerlink" title="(4)给文章添加valine评论功能"></a>(4)给文章添加valine评论功能</h3><p>进入主题文件的配置文件themes\matery_config.yml启用valine，其中需要设置Appid和appkey。此两项需要到<br><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">Leancloud官网</a><br><img src="https://s1.ax1x.com/2020/04/22/JNz2i6.jpg" alt=""><br>注册和身份验证通过后，新建应用，名字随意起。<br><img src="https://s1.ax1x.com/2020/04/22/JNzjSS.jpg" alt=""></p><p>再将信息填入</p><pre><code>valine:enable: trueappid: your app idappkey: your app keynotify: false # mail notifier , https://github.com/xCss/Valine/wikiverify: false # Verification codeplaceholder: just so soguest_info: nick,mail,linkpageSize: 10</code></pre><h3 id="5-修改头部幻灯片滤镜颜色和透明度"><a href="#5-修改头部幻灯片滤镜颜色和透明度" class="headerlink" title="(5)修改头部幻灯片滤镜颜色和透明度"></a>(5)修改头部幻灯片滤镜颜色和透明度</h3><p>打开matery.css，找到450行左右(建议直接注释掉，不好看)<br><img src="https://s1.ax1x.com/2020/04/22/JUSNmd.png" alt=""></p><h3 id="6-添加樱花飘落效果"><a href="#6-添加樱花飘落效果" class="headerlink" title="(6)添加樱花飘落效果"></a>(6)添加樱花飘落效果</h3><p>在<code>themes/matery/source/js</code>目录下新建<code>sakura.js</code>文件，打开这个网址<a href="https://cdn.jsdelivr.net/gh/baifeng66/cdn@1.1/source/js/sakura.js" target="_blank" rel="noopener">传送门</a>，将内容复制粘贴到sakura.js即可。</p><p>然后再themes/matery/layout/layout.ejs文件内添加下面的内容：</p><pre><code>&lt;script type="text/javascript"&gt;//只在桌面版网页启用特效var windowWidth = $(window).width();if (windowWidth &gt; 768) {    document.write('&lt;script type="text/javascript" src="/js/sakura.js"&gt;&lt;\/script&gt;');}&lt;/script&gt;</code></pre><h3 id="7-添加雪花飘落效果"><a href="#7-添加雪花飘落效果" class="headerlink" title="(7)添加雪花飘落效果"></a>(7)添加雪花飘落效果</h3><p>在<code>themes/matery/source/js</code>目录下新建<code>snow.js</code>文件，打开这个网址<a href="https://cdn.jsdelivr.net/gh/baifeng66/cdn@1.1/source/js/snow.js" target="_blank" rel="noopener">传送门</a>，将内容复制粘贴到<code>snow.js</code>即可。<br>然后再<code>themes/matery/layout/layout.ejs</code>文件内添加下面的内容：</p><pre><code>&lt;script src="/js/snow.js"&gt;&lt;/script&gt;</code></pre><h3 id="8-文章生成永久链接-提交github时会自动生成"><a href="#8-文章生成永久链接-提交github时会自动生成" class="headerlink" title="(8)文章生成永久链接(提交github时会自动生成)"></a>(8)文章生成永久链接(提交github时会自动生成)</h3><p>主题默认的文章链接配置是<br><code>permalink: :year/:month/:day/:title</code><br>这种生成的链接地址很长，文章版权的链接地址会出现一大串字符编码，一点也不好看。因此需要修改文章生成链接的格式。<br>首先再根目录下执行下面的命令：<br><code>npm install hexo-abbrlink --save</code><br>然后再根目录yml文件下添加如下配置：</p><pre><code>abbrlink:    alg: crc16   #算法： crc16(default) and crc32    rep: hex     #进制： dec(default) and hex: dec #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制</code></pre><p>然后再根目录yml文件下<code>permalink</code>的值修改为：<br><code>permalink: posts/:abbrlink.html  # 此处可以自己设置，也可以直接使用 :/abbrlink</code><br>生成完后，原md文件的Front-matter 内会增加abbrlink 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</p><h2 id="提交github（剧终）"><a href="#提交github（剧终）" class="headerlink" title="提交github（剧终）"></a>提交github（剧终）</h2><pre><code>hexo clean   // 清除缓存 网页正常情况下可以忽略此条命令hexo g       // 生成静态网页hexo d       // 开始部署</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html学习笔记</title>
      <link href="/2020/042250736.html"/>
      <url>/2020/042250736.html</url>
      
        <content type="html"><![CDATA[<h1 id="html学习笔记"><a href="#html学习笔记" class="headerlink" title="html学习笔记"></a>html学习笔记</h1><h2 id="一、实体"><a href="#一、实体" class="headerlink" title="一、实体"></a>一、实体</h2><pre><code>1.使用实体的原因：多个空格只认一个空格只认一个        2.在html中不能书写特殊符号：空格，大于小于        3.如果需要书写特殊符号那么就需要特殊符号：实体        4.实体的语法            &amp;实体的没名字                &amp;nbsp；：表示空格                &amp;gt；：大于号                &amp;lt：小于号                &amp;copy；：版权符号        5.怎样查询实体：w3school实体</code></pre><h2 id="二、meta标签"><a href="#二、meta标签" class="headerlink" title="二、meta标签"></a>二、meta标签</h2><pre><code>    1.meta主要用于表示元数据，元数据不给用户看    2.charset 指定网页字符集    3.name 指定数据名字    4.content 指定数据内容        keywords:表示网页关键字，可以设置多个关键字，用“，”隔开        description：网站描述会显示在搜索描述里面    5.title标签的内容：超链接上的标签显示  *********************将页面重定义到另一个网站</code></pre><h2 id="三、语义化标签"><a href="#三、语义化标签" class="headerlink" title="三、语义化标签"></a>三、语义化标签</h2><p>网页中html负责网页结构，<br>            在使用时应该关注语义而不是样式</p><pre><code>        标题标签            h1~h6            h1只有一个            一般情况下标题只用到h1~h3        块元素：在页面中独占一行block element            hgtoup:用来给标签分组           &lt;hgroup&gt;                    &lt;h1&gt;一级标题&lt;/h1&gt;                    &lt;h2&gt;二级标题&lt;/h2&gt;                 &lt;/hgroup&gt;        em标签：用于语音语调加重                  行内元素：不会独占一行:inline element            &lt;!-- strong :表示强调重要内容--&gt;            &lt;p&gt;你今天不需要&lt;strong&gt;完成作业&lt;/strong&gt;&lt;/p&gt;      blockquote:表示长引用，换行      鲁迅说：      &lt;blockquote&gt;          这句话我没说过      &lt;/blockquote&gt;      &lt;!-- 不换行：行标签 --&gt;      鲁迅说：      &lt;q&gt;          这句话我没说过      &lt;/q&gt;      &lt;!-- br --&gt;      &lt;br&gt;      这句话我没说过      &lt;!-- 乱码处理，点击utf-8 --&gt;    块元素 block element        --对页面进行布局，一块一块的    行内元素 inline element        --行内元素主要用来包裹文字        --一般情况下在块元素中放行内元素        --块元素中基本什么都能放        --p元素中不能放任何块元素    浏览器在解析网站时会修正不符合规范的内容    比如：        -标签写在外部        -p元素中嵌套了块元素        -根元素中出现了除了head，body以外的子元素    浏览器开发工具：element右键查看：内存中的代码存在 &lt;!--     布局标签（结构化语义）    header:头部    main:主体,一个页面只有一个    footer:尾部    nav:导航：一堆分类那块    aside：主体相关的不属于主体的内容    article：独立文章    section：独立区块：上面的标签都不能表示时    *div：没有语义，表示区块：目前来讲的主要布局元素    *span:行内元素,没有语义，主要用于选中文字 --&gt;</code></pre><h2 id="四、列表"><a href="#四、列表" class="headerlink" title="四、列表"></a>四、列表</h2><pre><code> &lt;!--     列表:list        -铅笔        -尺子        -橡皮    在html中也可以创建列表：        -有序列表        -无序列表        -定义列表        ul：无序列表            -使用li来表示列表项        ol：有序列表            -li        dl：定义序列            dt来表示定义内容            dd来解释说明        列表之间可以互相嵌套            ul中套ul --&gt;</code></pre><h2 id="五、超链接"><a href="#五、超链接" class="headerlink" title="五、超链接"></a>五、超链接</h2><pre><code>超链接：a标签：（行内标签）    -属性：href：指定跳转路径        -值可以是外部网站地址        -可以是内部页面地址：同一目录下就可以超链接a标签是行内标签，在a标签中可以嵌套除它自生外的任何元素</code></pre><h2 id="六、相对路径"><a href="#六、相对路径" class="headerlink" title="六、相对路径"></a>六、相对路径</h2><pre><code>    跳转服务器内部页面时要相对路径：       ./或../开头       可以省略       ./:表示当前文件所在目录            09.相对路径.html            在同一目录下可以不写       ../：上一级目录中查找       读当前，读下一级，读上一级;</code></pre><h2 id="七、超链接的其他应用"><a href="#七、超链接的其他应用" class="headerlink" title="七、超链接的其他应用"></a>七、超链接的其他应用</h2><pre><code> a标签的属性值：        target:指定超链接打开的位置:新标签            -_self 默认值:当前标签页            -_blank 新的页面中打开标签页 &lt;a href="#bottom"&gt;去底部&lt;/a&gt; &lt;a href="09.相对路径.html" target="_blank"&gt;超链接&lt;/a&gt;  回到顶部：        id属性:唯一不重复的            -每一个标签都可以添加id属性,唯一标识,同一个页面中不能相同出现id属性            -字母开头        可以跳转到指定位置:#标签 在开发中可以用：        -#去代表一个占位符会刷新页面        -javascript:;占位符,不会发生任何反应</code></pre><h2 id="八、图片标签"><a href="#八、图片标签" class="headerlink" title="八、图片标签"></a>八、图片标签</h2><pre><code>    图片标签:当前页面引入图片        img:自结束标签            属性                src：指定路径                img属于替换元素：img所引用的外部元素替换img                alt：图片属性,默认不会显示，无法加载时可能会显示                搜索引擎会按alt来识别图片                width：宽度                hight：高度                只修改一个：等比缩放                通常指定一个就行            注意：不建议修改图片大小                 移动端经常修改    图片的格式：        jpg:颜色多，不支持透明，不支持动图            -表示照片        gif:支持颜色少，支持简单透明，支持动图            -颜色单一的图片，动图        png:支持颜色丰富，支持复杂透明，不支持动图            -颜色丰富，复杂透明        webp:            谷歌新推出网页的图片格式            具备其他格式的所有有点，文件还小            效果一样用小的，效果不同用好的            兼容不好也可以复制图片代码直接等号后面       base64        -将图片用base64编码，这样可以将字符转换为字符，通过字符形式引入图片        -一般都是和网页一起加载的图片才会使用，不会出现延迟，加载速度快</code></pre><h2 id="九、内敛样式"><a href="#九、内敛样式" class="headerlink" title="九、内敛样式"></a>九、内敛样式</h2><pre><code>    iframe    内联框架：用于当前页面中引入别的网站        -src：网页路径        -frameborder：指定内联框架的边框：不好看            -会产生凹下去的外框，不好看                -1：打开                -0：关闭</code></pre><h2 id="十、音视频"><a href="#十、音视频" class="headerlink" title="十、音视频"></a>十、音视频</h2><pre><code>    audio:像页面中引入音频文件    属性：        -controls：是否允许用户控制        -autoplay：自动播放            -如果设置，打开页面时会自动播放，目前大部分浏览器不会自动播放            -先播放一次之后就可以自动播放了，IE可以        loop:循环播放    除了scr指定文件之外;还可以用scorce来指定文件        -指定多个文件，不会全部执行，找一个支持的    embed:老版本的播放，自动播放，第二次会变很小：指定宽高        -type：指定类型    video：引入视频文件    属性：        -autoplay        -loop        -音频通常用source，这样兼容性好 一般不用这种绝对路径的方法         allowFullScreen="true"：全屏         一般引入：和之前一样：</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> 网页开发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
