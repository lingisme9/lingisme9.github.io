<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>人工智能</title>
      <link href="/2020/092226468.html"/>
      <url>/2020/092226468.html</url>
      
        <content type="html"><![CDATA[<h1 id="人工智能作业"><a href="#人工智能作业" class="headerlink" title="人工智能作业"></a>人工智能作业</h1><h2 id="1-第一章："><a href="#1-第一章：" class="headerlink" title="1.第一章："></a>1.第一章：</h2><pre><code>1.为什么神经网络在人工智能第一次浪潮中并没有获得成功，而如今却获得突飞猛进的进展？答：    50年代末，F·Rosenblatt设计制作了“感知机”，它是一种多层的神经网络。这项工作首次把人工神经网络的研究从理论探讨付诸工程实践。当时，世界上许多实验室仿效制作感知机，分别应用于文字识别、声音识别、声纳信号识别以及学习记忆问题的研究。然而，这次人工神经网络的研究高潮未能持续很久，许多人陆续放弃了这方面的研究工作，这是因为当时数字计算机的发展处于全盛时期，许多人误以为数字计算机可以解决人工智能、模式识别、专家系统等方面的一切问题，使感知机的工作得不到重视；其次，当时的电子技术工艺水平比较落后，主要的元件是电子管或晶体管，利用它们制作的神经网络体积庞大，价格昂贵，要制作在规模上与真实的神经网络相似是完全不可能的；另外，在1968年一本名为《感知机》的著作中指出线性感知机功能是有限的，它不能解决如异或这样的基本问题，而且多层网络还不能找到有效的计算方法，这些论点促使大批研究人员对于人工神经网络的前景失去信心。60年代末期，人工神经网络的研究进入了低潮。另外，在60年代初期，Widrow提出了自适应线性元件网络，这是一种连续取值的线性加权求和阈值网络。后来，在此基础上发展了非线性多层自适应网络。当时，这些工作虽未标出神经网络的名称，而实际上就是一种人工神经网络模型。随着人们对感知机兴趣的衰退，神经网络的研究沉寂了相当长的时间。80年代初期，模拟与数字混合的超大规模集成电路制作技术提高到新的水平，完全付诸实用化，此外，数字计算机的发展在若干应用领域遇到困难。这一背景预示，向人工神经网络寻求出路的时机已经成熟。美国的物理学家Hopfield于1982年和1984年在美国科学院院刊上发表了两篇关于人工神经网络研究的论文，引起了巨大的反响。人们重新认识到神经网络的威力以及付诸应用的现实性。随即，一大批学者和研究人员围绕着 Hopfield提出的方法展开了进一步的工作，形成了80年代中期以来人工神经网络的研究热潮。</code></pre><h2 id="2-8数码问题"><a href="#2-8数码问题" class="headerlink" title="2.8数码问题"></a>2.8数码问题</h2><pre><code>在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。</code></pre><p><strong>分析】</strong></p><p>题目读完第一感觉是和求解最短路径问题类似，考虑使用BFS，状态很好找，每次移动空格就会形成一种新的状态，例如：</p><p><img src="https://img-blog.csdn.net/20180116201941897?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjI4MzQ2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><img src="https://p-blog.csdn.net/images/p_blog_csdn_net/zuzubo/239856/o_Snap1.gif" alt="img"></p><p><img src="https://img-blog.csdn.net/20180428120116514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDQ1MDE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>八数码问题是个典型的状态图搜索问题。搜索方式有两种基本的方式，即树式搜索和线式搜索。搜索策略大体有盲目搜索和启发式搜索两大类。盲目搜索就是无“向导”的搜索，（例如深度优先搜索，广度优先搜索），其效率极其低下。启发式搜索就是有“向导”的搜索，有更好的效率</p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200922174650256.png" alt="image-20200922174650256"></p><p><strong>一、状态如何表示？</strong></p><p>1.每个状态都用3*3的数组表示，但是BFS中需要入队出队，比较麻烦而且空间占用较大</p><p>2.状态压缩，采用一个整数保存状态的数字序列，例如状态1表示为283104765,状态2表示为203184765</p><p><strong>二、如何判重？</strong></p><p>1.如果空间允许，开一个876543210大小的bool数组，某个序列出现就将数组值置为1；但是竞赛中一般都是限制128M(大约10000000)，这个数组开不下来。</p><p>2.虽然状态范围是012345678–876543210，但是中间真正有效的只有9！=362800，因为数字不可能出现重复；因此可以考虑开一个数组大小为9！整型数组A和bool数组B，然后生成0-8这9个数码的全排列并按照升序或者降序存入数组中，要判断某个状态（一种排列方式）是否出现过，直接通过二分查找的方式找到该排列在A中的下标i，然后查看数组B[i]为true还是false；如果为true则出现过，如果为false则将状态入队，并设置B[i]=true;</p><p>3.其实从方案2中我们已经看到，判重的实质就是建立状态数字串（一个int数据）和是否出现（一个bool数据）之间的联系，而STL中刚好提供了map&lt;key,value&gt;这样一种容器，我们可以将状态数字串作为key，是否出现作为value直接建立起状态–是否出现的联系。</p><p>4.使用hash判重，将状态数字串通过某种映射f(x)从012345678–876543210这样一个大集合，映射到128M范围之内；这里采用简单的hash，取模一个大质数，只要这个质数大于9！即可；当然这里可能出现冲突，也就是key1!=key2但是f(key1)==f(key2),hash算法只能减少冲突不能避免冲突。这里如何减少冲突呢？挂链表，当key1!=key2但是f(key1)==f(key2),则将key2挂到key1后面；当然这里如果使用康托展开可以完美一一映射而不冲突，但是我不会(<del>^</del>)。</p><p><strong>三、搜索方法的选择</strong></p><p><strong>1.BFS（广度优先搜索）</strong></p><p>广度优先遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。</p><p>上文所述树的广度优先遍历动图如下，每个节点的值即为它们的遍历顺序。所以广度优先遍历也叫层序遍历，先遍历第一层(节点 1)，再遍历第二层(节点 2，3，4)，第三层(5，6，7，8)，第四层(9，10)。</p><p><img src="https://s2.51cto.com/oss/202004/16/29dc30c1546cc73846153359b0fad8fb.gif" alt="img"></p><p>深度优先遍历用的是栈，而广度优先遍历要用队列来实现，我们以下图二叉树为例来看看如何用队列来实现广度优先遍历。</p><p><img src="https://s4.51cto.com/oss/202004/16/1ba485c575477d00a51b44640671245e.png" alt="img"></p><p>动图如下：</p><p><img src="https://s4.51cto.com/oss/202004/16/a2c7c61edcadffeed85c10f53f1c988c.gif" alt="img"></p><pre><code>/**  * 使用队列实现 bfs  * @param root  */ private static void bfs(Node root) {     if (root == null) {         return;     }     Queue&lt;Node&gt; stack = new LinkedList&lt;&gt;();     stack.add(root);     while (!stack.isEmpty()) {         Node node = stack.poll();         System.out.println("value = " + node.value);         Node left = node.left;         if (left != null) {             stack.add(left);         }         Node right = node.right;         if (right != null) {             stack.add(right);         }     } } </code></pre><p><strong>2.DFS（深度优先搜索）</strong></p><p>主要思路是从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。</p><p>1、我们从根节点 1 开始遍历，它相邻的节点有 2，3，4，先遍历节点 2，再遍历 2 的子节点 5，然后再遍历 5 的子节点 9。</p><p><img src="https://s4.51cto.com/oss/202004/16/ca375e4d1d4a377b4a15dc9e548123d1.png" alt="img"></p><p>2、上图中一条路已经走到底了(9是叶子节点，再无可遍历的节点)，此时就从 9 回退到上一个节点 5，看下节点 5 是否还有除 9 以外的节点，没有继续回退到 2，2 也没有除 5 以外的节点，回退到 1，1 有除 2 以外的节点 3，所以从节点 3 开始进行深度优先遍历，如下：</p><p><img src="https://s3.51cto.com/oss/202004/16/2354c3d3f9abc912f6500140ee92458a.png" alt="img"></p><p>3、同理从 10 开始往上回溯到 6, 6 没有除 10 以外的子节点，再往上回溯，发现 3 有除 6 以外的子点 7，所以此时会遍历 7。</p><p><img src="https://s2.51cto.com/oss/202004/16/7e0a19b7de2356a352661c4b0f803f71.png" alt="img"></p><p>3、从 7 往上回溯到 3， 1，发现 1 还有节点 4 未遍历，所以此时沿着 4， 8 进行遍历,这样就遍历完成了。</p><p>完整的节点的遍历顺序如下(节点上的的蓝色数字代表)：</p><p><img src="https://s5.51cto.com/oss/202004/16/92f602a1eaa301784085b8a3c4b948c0.png" alt="92f602a1eaa301784085b8a3c4b948c0.png (381×337)"></p><p>看到以上的遍历不难发现这就是树的前序遍历,实际上不管是前序遍历，还是中序遍历，亦或是后序遍历，都属于深度优先遍历。</p><p>那么深度优先遍历该怎么实现呢，有递归和非递归两种表现形式，接下来我们以二叉树为例来看下如何分别用递归和非递归来实现深度优先遍历。</p><p><strong>1、递归实现</strong></p><p>递归实现比较简单，由于是前序遍历，所以我们依次遍历当前节点，左节点，右节点即可，对于左右节点来说，依次遍历它们的左右节点即可，依此不断递归下去，直到叶节点(递归终止条件)，代码如下：</p><pre><code>public class Solution {     private static class Node {         /**          * 节点值          */         public int value;         /**          * 左节点          */         public Node left;         /**          * 右节点          */         public Node right;         public Node(int value, Node left, Node right) {             this.value = value;             this.left = left;             this.right = right;         }     }     public static void dfs(Node treeNode) {         if (treeNode == null) {             return;         }         // 遍历节点         process(treeNode)         // 遍历左节点         dfs(treeNode.left);         // 遍历右节点         dfs(treeNode.right);     } } </code></pre><p>递归的表达性很好，也很容易理解，不过如果层级过深，很容易导致栈溢出。所以我们重点看下非递归实现。</p><p><strong>2、非递归实现</strong></p><p>仔细观察深度优先遍历的特点，对二叉树来说，由于是先序遍历(先遍历当前节点，再遍历左节点，再遍历右节点)，所以我们有如下思路：</p><p>对于每个节点来说，先遍历当前节点，然后把右节点压栈，再压左节点(这样弹栈的时候会先拿到左节点遍历，符合深度优先遍历要求)。</p><p>弹栈，拿到栈顶的节点，如果节点不为空，重复步骤 1， 如果为空，结束遍历。</p><p>我们以以下二叉树为例来看下如何用栈来实现 DFS。</p><p><img src="https://s2.51cto.com/oss/202004/16/b2a7d9fdc8fa1898a569255957428d94.png" alt="b2a7d9fdc8fa1898a569255957428d94.png (355×287)"></p><p>整体动图如下：</p><p><img src="C:%5CUsers%5C51403%5CDesktop%5Ce1e6a44251b69cd3b930f3071a71ffd8.gif" alt="e1e6a44251b69cd3b930f3071a71ffd8"></p><p>整体思路还是比较清晰的，使用栈来将要遍历的节点压栈，然后出栈后检查此节点是否还有未遍历的节点，有的话压栈，没有的话不断回溯(出栈)，有了思路，不难写出如下用栈实现的二叉树的深度优先遍历代码：</p><pre><code>/**  * 使用栈来实现 dfs  * @param root  */ public static void dfsWithStack(Node root) {     if (root == null) {         return;     }     Stack&lt;Node&gt; stack = new Stack&lt;&gt;();     // 先把根节点压栈     stack.push(root);     while (!stack.isEmpty()) {         Node treeNode = stack.pop();         // 遍历节点         process(treeNode)         // 先压右节点         if (treeNode.right != null) {             stack.push(treeNode.right);         }         // 再压左节点         if (treeNode.left != null) {             stack.push(treeNode.left);         }     } } </code></pre><p><strong>3.启发式搜索</strong></p><p>  启发式搜索：启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无谓的搜索路径，提高了效率</p><p><strong>解决此问题的启发策略：</strong></p><p>每次移动的时候，正确位置数码的个数要大于交换前正确位置数码个数。</p><p>正确位置数码个数：每个数码的位置与最终格局的对比，如果位置相同，则说明此数码在正确位置。</p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200922175210300.png" alt="image-20200922175210300"></p><p>图1.3中右边为最终格局，左边为当前格局，红色字体标识的数码为 正确位置数码，由此可以发现其正确位置的数码个数为4个。那么图1.2中正确数码如下图所示：</p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200922175336459.png" alt="image-20200922175336459"></p><p>由上图所示可得，正确位置数码个数大于等于4的只有左下方的格局，那么下一步选择的就是左下方的格局，再次调用次算法如下图：</p><p><img src="C:%5CUsers%5C51403%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200922175404359.png" alt="image-20200922175404359"></p><p>由八数码问题的部分状态图可以看出，从初始节点开始，在通向目标节点的路径上，各节点的数码格局同目标节点相比较，其数码不同的位置个数在逐渐减少，最后为零。所以，这个数码不同的位置个数便是标志一个节点到目标节点距离远近的一个启发性信息，利用这个信息就可以指导搜索。即可以利用启发信息来扩展节点的选择，减少搜索范围，提高搜索速度。</p><p> 启发函数设定。对于八数码问题，可以利用棋局差距作为一个度量。搜索过程中，差距会逐渐减少，最终为零，为零即搜索完成，得到目标棋局。</p><pre><code>/*程序名：八数码问题描述：主要函数列表：      1.show()     显示当前待调整数码矩阵      2.exchange() 交换数码中的 begin[row_one][column_one] 与 begin[row_two][column_two] 这两个数      3.judge()    判断待调整的数码与最终数码相比正确位置数码的个数      4.yidong()   将待调整数码从开始位置移动到终止位置，并将其过程输出      5.shuru()    有用户输入待调整的数码矩阵最初状态的数，并将其存入到begin[][]数组中其它说明：此程序运用到启发式搜索的策略，          （1）：将空格的地方存储零，这样便于操作          （2）：每次交换0上下左右4个方向元素的位置，当交换位置后正确数码个数 大于或等于 交换前正确数码的个数则算交换成功，                 交换成功则重复步骤2，失败的话则跳回上一轮交换。          （3）：当交换到最终所有的数码的位置都正确时结束*/#include"stdio.h"#define num 3 //宏定义数码的行列数为3/*显示当前待调整数码矩阵*/void show(int begin[num][num])  {    for(int i = 0; i &lt; num; i++)    {        for(int j = 0; j &lt; num; j++)            printf("%d ", begin[i][j]);        printf("\n");    }    printf("\n");}/*交换数码中的 begin[row_one][column_one] 与 begin[row_two][column_two] 这两个数*/void exchange(int begin[num][num], int row_one, int column_one, int row_two, int column_two)  {    int temp;    temp = begin[row_two][column_two] ;    begin[row_two][column_two] = begin[row_one][column_one];    begin[row_one][column_one] = temp;}/*判断待调整的数码与最终数码相比正确位置数码的个数*/int judge(int begin[num][num], int end[num][num]) {    int count=0;           //count记录数码中正确位置的个数    for(int i = 0; i &lt; num; i++)   //检查当前图形的正确度        for(int j = 0; j &lt; num; j++)        {            if(begin[i][j] == end[i][j] &amp;&amp; end[i][j] != 0)                count++;        }    return count;           //返回数码中正确位置的个数}/* 将待调整数码从开始位置移动到终止位置，并将其过程输出*/int yidong(int begin[num][num], int end[num][num]           , int right, int jishu, int ji_shu[50][3][3]           , int biaoji, int row, int column) //biaoji存储上一轮移动的反方向代号{     int temp_zhi;    show(begin);   //显示数组矩阵    if(jishu &gt;= 20)        return 0;    int node;  //,node为标记    int temp;               //存储当前待调整数码正确的个数    for(int q=0; q&lt;jishu; q++)  //检查交换后的end[][]图形是否先前已经遍历过了    {        node = 1;        for(int w=0; w&lt;num &amp;&amp; node; w++)            for(int r=0; r&lt;num &amp;&amp; node; r++)                if(ji_shu[q][w][r] != begin[w][r])                    node = 0;        if(node == 1)   //如果先前遍历过，返回0        {            return 0;        }    }    for(int i = 0; i &lt; num; i++)           for(int j = 0; j &lt; num; j++)            ji_shu[jishu][i][j] = begin[i][j];    if(right == num * num - 1)  //如果待调整数码与最终数码完全相同时，返回1        return 1;    if(row &gt; 0 &amp;&amp; biaoji != 0)             //存储0的位置不是在第一行    {        exchange(begin, row - 1, column, row , column);  //将0与其上面的元素交换存储位置        temp = judge(begin, end);        if(temp &lt; right)   //如果交换后正确数码的个数不大于原来正确数码的个数            exchange(begin, row - 1, column, row , column); //再将其交换回来                else if(temp &gt;= right)          //如果交换后正确数码的个数大于或等于原来正确数码的个数        {            temp_zhi = yidong(begin, end, temp, jishu+1, ji_shu, 2, row-1, column);             if( temp_zhi == 1)  //进行下一步的移动                 return 1;            exchange(begin, row - 1, column, row , column); //再将其交换回来        }    }    if(column &gt; 0 &amp;&amp; biaoji != 1)    {           exchange(begin, row, column - 1, row , column); //将0与其左边的元素交换存储位置        temp = judge(begin, end);                if(temp &lt; right)                 exchange(begin, row, column - 1, row , column);                    else if(temp &gt;= right)        {            temp_zhi = yidong(begin, end, temp, jishu+1, ji_shu ,3, row, column - 1);            if(temp_zhi == 1)                   return 1;            exchange(begin, row, column - 1, row , column);        }    }    if(row &lt; num-1 &amp;&amp; biaoji != 2)    {        exchange(begin, row + 1, column, row , column); //将0与其下面的元素交换存储位置        temp = judge(begin, end);            if(temp &lt; right)             exchange(begin, row + 1, column, row , column);        else if(temp &gt;= right)        {            temp_zhi =yidong(begin, end, temp, jishu+1, ji_shu, 0, row+1, column);           if(temp_zhi == 1)                return 1;           exchange(begin, row + 1, column, row , column);        }    }    if(column &lt; num-1 &amp;&amp; biaoji != 3)    {        exchange(begin, row, column + 1, row , column); //将0与其右边的元素交换存储位置        temp = judge(begin, end);            if(temp &lt; right)               exchange(begin, row, column + 1, row , column);                else if(temp &gt;= right)          {            temp_zhi = yidong(begin, end, temp, jishu+1, ji_shu, 1, row, column+1);            if(temp_zhi == 1)                 return 1;            exchange(begin, row, column + 1, row , column);            }    }    return 0;   //移动失败，返回0}/*有用户输入待调整的数码矩阵最初状态的数，并将其存入到begin[][]数组中*/void shuru(int begin[][num],int blank[])  {    int temp, node, zero = 0;    for (int i = 0; i &lt; num; i++)        for(int j = 0; j &lt; num; j++)        {            node = 1;            printf("请输入第%d行，第%d列的元素的值：", i+1, j+1);            scanf("%d", &amp;temp);            for (int q = 0; q &lt;= i &amp;&amp; node == 1; q++)  //当输入的值有重复的，提示重新输入                for (int w = 0; w &lt; j; w++)                    if(temp == begin[q][w])                    {                        printf("输入重复，请重新输入\n");                        node = 0;                        j--;                        break;                    }            if(temp &lt; 0 || temp &gt; num*num-1)   //当输入的值不是在数码的区间范围内时，提示重新输入            {                printf("请输入从%d到%d的数\n", zero, num*num-1);                node = 0;                j--;            }            if(node == 1)   //如果输入满足条件                {                if(temp == 0) //如果输入的值为零，由blank[0]记录行号，blank[1]记录列号                {                    blank[0] = i;                    blank[1] = j;                }                begin[i][j] = temp;//将满足条件的值存储起来            }        }}int main(){    int jishu = 0, ji_shu[50][3][3];//jishu存储已经遍历过的八数码图形的个数，jishu[][][]存储已经遍历过的八数码图形的形状    int row;     //存储数字零的行数    int column;  //存储数字零的列数    int begin[num][num], blank[2],count=1;         int end[num][num] = {1, 2, 3, 8, 0, 4, 7, 6, 5};  //给最终状态的数码矩阵赋值    printf ("-------%d数码游戏开始！--------\n", num);    shuru(begin, blank);   //输入带调整状态的数码矩阵的值    row = blank[0];    column = blank[1];    if(yidong (begin, end,judge(begin,end),jishu,ji_shu,4,row,column) == 0)         printf("\n此8数码的问题可能无解！");    else        show(begin);    getchar();getchar();    return 0;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>辽大自动疫情打卡</title>
      <link href="/2020/072037829.html"/>
      <url>/2020/072037829.html</url>
      
        <content type="html"><![CDATA[<pre><code># 实现浏览器打开搜索# 引入webdriverfrom selenium.webdriver.common.keys import Keysfrom selenium import webdriverfrom openpyxl import load_workbookimport scheduledef job():        # 打开excel文件，获取处于活跃状态的表格        workbook = load_workbook(filename='num.xlsx')        sheet = workbook.active        for i in [2, 3, 4, 5 ,6 ,7 ,8 ,9]:                # 实列化对象，选择启用谷歌，打开浏览器                driver = webdriver.Chrome()                driver.implicitly_wait(10)                # 访问网页                driver.get("http://tjxx.lnu.edu.cn/login.asp")                # 输入账号                cell1 = sheet.cell(row=i, column=1).value                ele = driver.find_element_by_name("userid")                ele.send_keys(cell1)                # 输入密码                paw = sheet.cell(row=i, column=2).value                ele1 = driver.find_element_by_name("userpwd")                ele1.send_keys(paw)                # 点击登录                driver.find_element_by_id("formSubmitBtn").click()                # 选中第一个无                ele4 = driver.find_element_by_xpath("/html/body/div[1]/form/div[3]/div[2]/label[1]/div[2]/input")                driver.execute_script("arguments[0].click();", ele4)                # 选中第二个无                ele5 = driver.find_element_by_xpath("/html/body/div[1]/form/div[4]/div[2]/label[1]/div[2]/input")                driver.execute_script("arguments[0].click();", ele5)                # 选中健康                ele6 = driver.find_element_by_xpath("/html/body/div[1]/form/div[5]/div[2]/label[1]/div[2]/input")                driver.execute_script("arguments[0].click();", ele6)                # 选中隔离                ele7 = driver.find_element_by_xpath("/html/body/div[1]/form/div[6]/div[2]/label[1]/div[2]/input")                driver.execute_script("arguments[0].click();", ele7)                # 是否在校                ele8 = driver.find_element_by_xpath("/html/body/div[1]/form/div[7]/div[2]/label[1]/div[2]/input")                driver.execute_script("arguments[0].click();", ele8)                # # 提交                # driver.find_element_by_xpath("/html/body/div[1]/form/div[8]/a").click()                # # 确认提交                # driver.find_element_by_xpath("/html/body/div[3]/div[2]/div[2]/a[2]").click()                # 退出                # driver.find_element_by_xpath("/html/body/div/div[2]/div[3]/a").click()                driver.quit()                print("提交成功")schedule.every().day.at("21:48").do(job)while True:    schedule.run_pending()time.sleep(3)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python+mysql项目</title>
      <link href="/2020/06141769.html"/>
      <url>/2020/06141769.html</url>
      
        <content type="html"><![CDATA[<h1 id="一起旅游项目"><a href="#一起旅游项目" class="headerlink" title="一起旅游项目"></a>一起旅游项目</h1><p><img src="https://s1.ax1x.com/2020/06/14/tz6Sqx.png" alt="tz6Sqx.png"></p><h2 id="一、会员注册页面"><a href="#一、会员注册页面" class="headerlink" title="一、会员注册页面"></a>一、会员注册页面</h2><p><img src="https://s1.ax1x.com/2020/06/14/tzDmUe.png" alt="tzDmUe.png"></p><h3 id="1、从网站找到路径regester"><a href="#1、从网站找到路径regester" class="headerlink" title="1、从网站找到路径regester"></a>1、从网站找到路径regester</h3><p><img src="https://s1.ax1x.com/2020/06/14/tzD8Df.png" alt="tzD8Df.png"><br><img src="https://s1.ax1x.com/2020/06/14/tzD0vq.png" alt="tzD0vq.png"></p><p><img src="https://s1.ax1x.com/2020/06/14/tzDcaF.png" alt="tzDcaF.png"></p><p>分析regester函数<br><img src="https://s1.ax1x.com/2020/06/14/tzr9Z8.png" alt="tzr9Z8.png"></p><p>找到RegesterFrom类定义的位置<br><img src="https://s1.ax1x.com/2020/06/14/tzr8zR.png" alt="tzr8zR.png"></p><p><img src="https://s1.ax1x.com/2020/06/14/tzr0Fe.png" alt="tzr0Fe.png"></p><p>分析regester函数<br><img src="https://s1.ax1x.com/2020/06/14/tzr4YQ.png" alt="tzr4YQ.png"></p><p>转到被渲染的html</p><p><img src="https://s1.ax1x.com/2020/06/14/tzsVte.png" alt="tzsVte.png"></p><p><img src="https://s1.ax1x.com/2020/06/14/tzsaXq.png" alt="tzsaXq.png"></p><p>转到被渲染的html<br><img src="https://s1.ax1x.com/2020/06/14/tzsIAO.png" alt="tzsIAO.png"></p><p><img src="https://s1.ax1x.com/2020/06/14/tzyVbV.png" alt="tzyVbV.png"></p><p><img src="https://s1.ax1x.com/2020/06/14/tzyQ29.png" alt="tzyQ29.png"></p><p>表单规则<br><img src="https://s1.ax1x.com/2020/06/14/tzyrrt.png" alt="tzyrrt.png"></p><p><img src="https://s1.ax1x.com/2020/06/14/tzyoq0.png" alt="tzyoq0.png"></p><p>逻辑判断：邮箱是否已经注册<br><img src="https://s1.ax1x.com/2020/06/14/tz6Yyn.png" alt="tz6Yyn.png"></p><p><img src="https://s1.ax1x.com/2020/06/14/tz6qmt.png" alt="tz6qmt.png"></p><p><img src="https://s1.ax1x.com/2020/06/14/tzcZhF.png" alt="tzcZhF.png"></p><p><img src="https://s1.ax1x.com/2020/06/14/tzcimq.png" alt="tzcimq.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法总结</title>
      <link href="/2020/061457899.html"/>
      <url>/2020/061457899.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><h2 id="二分归并排序"><a href="#二分归并排序" class="headerlink" title="二分归并排序"></a>二分归并排序</h2><h5 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h5><p>使用二分归并排序算法，对n个不同的数构成的数组A[1…n]进行排序，其中n=2^k</p><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>二分归并排序是一种分治算法。这个算法不断地将一个数组分为两部分，分别对左子数组和右子数组排序，然后将两个数组合并为新的有序数组。<br>算法步骤如下：<br>（1） 分解：分解待排序的n个元素的数组成各具n/2个元素的两个子数组。<br>（2） 解决：使用归并排序递归地排序两个子序列。<br>（3） 合并：合并两个已排序的子序列以产生排序的答案。<br>当待排序的数组长度为1时，递归“开始回升”，在这种情况下不要做任何工作，因为长度为1的每个数组都已排好序。</p><p>下面以绘图方式演示通过二分归并排序算法的过程</p><pre><code>int Merge(int a[],int low, int mid, int high)// 合并函数{    int j, k, h;    j = low;    h = mid + 1;    k = low;    while (j&lt;=mid&amp;&amp;h&lt;=high)    // 将左右两端数据进行比较，放入辅助数组中    {        if (a[j] &lt; a[h])            b[k++] = a[j++];        else            b[k++] = a[h++];    }    // 将剩余的数据加入到辅助数组中    while (j &lt;= mid)    {        b[k++] = a[j++];    }    while (h&lt;=high)    {        b[k++] = a[h++];    }    for (k = low; k &lt;= high; k++)// 将辅助数组的数据复制到原数组的对应位置上    {        a[k] = b[k];    }}int MergeSort(int a[],int low,int high)    // 递归分组函数{    if (low &lt; high)    {        int mid = (low + high) / 2;        MergeSort(a,low, mid);        MergeSort(a,mid + 1, high);        Merge(a,low, mid, high);// 调用Merge函数，合并两组数据     }}</code></pre><h5 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h5><p>二分归并排序算法是一种稳定的排序，其时间复杂度是O(logn) 。<br>Merge算法比较次数：</p><pre><code>最差情况下，比较次数为n-1，时间复杂度为O(nlogn)，例如：2,4,6;1,3,5 比较次数为5最优情况下，比较次数为n/2，时间复杂度为O(nlogn)，例如：1,2,3;4,5,6 比较次数为3平均复杂度为O(nlogn)</code></pre><p>递归方程如下：<br><img src="https://s1.ax1x.com/2020/06/14/tzENQK.png" alt="tzENQK.png"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>它是一种稳定的排序方法。快速排序利用分治思想，将待排序数组分成左右两个部分，然后对其分别递归调用快速排序算法</p><pre><code>下面通过一个例子介绍快速排序算法的思想，假设要对数组a[10]={6，1，2，7，9，3，4，5，10，8}进行排序，首先要在数组中选择一个数作为基准值，这个数可以随意选择，在这里，我们选择数组的第一个元素a[0]=6作为基准值，接下来，我们需要把数组中小于6的数放在左边，大于6的数放在右边</code></pre><p>我们设置两个“哨兵”，记为“哨兵i”和“哨兵j”，他们分别指向数组的第一个元素和最后一个元素，即i=0，j=9。首先哨兵j开始出动，哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。</p><p>最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。此时就需要交换i和j指向的元素的值。<br><img src="https://s1.ax1x.com/2020/06/14/tzthiq.png" alt="tzthiq.png"><br>交换之后的数组变为a[10]={6，1，2，5，9，3，4，7，10，8}：</p><p>第一次交换至此结束。接下来，由于哨兵i和哨兵j还没有相遇，于是哨兵j继续向前，发现比6小的4之后停下；哨兵i继续向前，发现比6大的9之后停下，两者再进行交换。交换之后的数组变为a[10]={6，1，2，5，4，3，9，7，10，8}。</p><p><img src="https://s1.ax1x.com/2020/06/14/tztxW6.png" alt="tztxW6.png"></p><p>第二次交换至此结束。接下来，哨兵j继续向前，发小比6小的3停下来；哨兵i继续向前，发现i==j了！！！于是，这一轮的探测就要结束了，此时交换a[i]与基准的值，数组a就以6为分界线，分成了小于6和大于6的左右两部分：a[10]={3，1，2，5，4，6，9，7，10，8}。</p><p><img src="https://s1.ax1x.com/2020/06/14/tzNkTA.png" alt="tzNkTA.png"><br><img src="https://s1.ax1x.com/2020/06/14/tzNlwj.png" alt="tzNlwj.png"></p><p>至此，第一轮快速排序完全结束，接下来，对于6左边的半部分3，1，2，5，4，执行以上过程；对于6右边的半部分9，7，10，8，执行以上过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列：1 2 3 4 5 6 7 8 9 10，到此，排序完全结束。</p><pre><code>#include &lt;stdio.h&gt;int a[101],n;//定义全局变量，这两个变量需要在子函数中使用void quicksort(int left, int right) {    int i, j, t, temp;    if(left &gt; right)        return;    temp = a[left]; //temp中存的就是基准数    i = left;    j = right;    while(i != j) { //顺序很重要，要先从右边开始找        while(a[j] &gt;= temp &amp;&amp; i &lt; j)            j--;        while(a[i] &lt;= temp &amp;&amp; i &lt; j)//再找右边的            i++;               if(i &lt; j)//交换两个数在数组中的位置        {            t = a[i];            a[i] = a[j];            a[j] = t;        }    }    //最终将基准数归位    a[left] = a[i];    a[i] = temp;    quicksort(left, i-1);//继续处理左边的，这里是一个递归的过程    quicksort(i+1, right);//继续处理右边的 ，这里是一个递归的过程}int main() {    int i;    //读入数据    printf("请输入数组元素个数：");     scanf("%d", &amp;n);    for(i = 1; i &lt;= n; i++)        scanf("%d", &amp;a[i]);    quicksort(1, n); //快速排序调用    //输出排序后的结果    for(i = 1; i &lt; n; i++)        printf("%d ", a[i]);    printf("%d\n", a[n]);    return 0;}</code></pre><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><pre><code>二分査找就是折半查找，其基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）。#include &lt;stdio.h&gt;int binary_search(int key,int a[],int n) //自定义函数binary_search(){    int low,high,mid,count=0,count1=0;    low=0;    high=n-1;    while(low&lt;high)    //査找范围不为0时执行循环体语句    {        count++;    //count记录査找次数        mid=(low+high)/2;    //求中间位置        if(key&lt;a[mid])    //key小于中间值时            high=mid-1;    //确定左子表范围        else if(key&gt;a[mid])    //key 大于中间值时            low=mid+1;    //确定右子表范围        else if(key==a[mid])    //当key等于中间值时，证明查找成功        {            printf("查找成功!\n 查找 %d 次!a[%d]=%d",count,mid,key);    //输出査找次数及所査找元素在数组中的位置            count1++;    //count1记录查找成功次数            break;        }    }    if(count1==0)    //判断是否查找失敗        printf("查找失敗!");    //査找失敗输出no found    return 0;}int main(){    int i,key,a[100],n;    printf("请输入数组的长度：\n");    scanf("%d",&amp;n);    //输入数组元素个数    printf("请输入数组元素：\n");    for(i=0;i&lt;n;i++)        scanf("%d",&amp;a[i]);    //输入有序数列到数组a中    printf("请输入你想查找的元素：\n");    scanf("%d",&amp;key);    //输入要^找的关键字    binary_search(key,a,n);    //调用自定义函数    printf("\n");    return 0;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP</title>
      <link href="/2020/060911574.html"/>
      <url>/2020/060911574.html</url>
      
        <content type="html"><![CDATA[<h1 id="PHP学习笔记"><a href="#PHP学习笔记" class="headerlink" title="PHP学习笔记"></a>PHP学习笔记</h1><h2 id="1、环境安装：apache-PHP-MySQL"><a href="#1、环境安装：apache-PHP-MySQL" class="headerlink" title="1、环境安装：apache+PHP+MySQL"></a>1、环境安装：apache+PHP+MySQL</h2><h2 id="2、直接安装wampserver集成开发环境"><a href="#2、直接安装wampserver集成开发环境" class="headerlink" title="2、直接安装wampserver集成开发环境"></a>2、直接安装wampserver集成开发环境</h2><h3 id="1-访问自己："><a href="#1-访问自己：" class="headerlink" title="1.访问自己："></a>1.访问自己：</h3><p><img src="https://s1.ax1x.com/2020/06/09/tI9gat.png" alt="tI9gat.png"><br>访问到的这些界面放在那里<br><a href="https://imgchr.com/i/tICiIx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/09/tICiIx.png" alt="tICiIx.png"></a><br>目录树结构：<br><img src="https://s1.ax1x.com/2020/06/09/tICrWT.png" alt="tICrWT.png"><br>访问某个文件夹，默认访问index.php或者index.html</p><h2 id="3、编辑器的安装zendstudio"><a href="#3、编辑器的安装zendstudio" class="headerlink" title="3、编辑器的安装zendstudio"></a>3、编辑器的安装zendstudio</h2><h2 id="4、PHP基础语法"><a href="#4、PHP基础语法" class="headerlink" title="4、PHP基础语法"></a>4、PHP基础语法</h2><h3 id="PHP文件可以嵌入html中"><a href="#PHP文件可以嵌入html中" class="headerlink" title="PHP文件可以嵌入html中"></a>PHP文件可以嵌入html中</h3><pre><code>1、文件末尾的？》可以省略，所有语句都加上分号，便于维护，不强制2、结束标记就隐含了一个分号（有结束标志）</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>1、单行：//2.多行：/**/</code></pre><h3 id="空格处理"><a href="#空格处理" class="headerlink" title="空格处理"></a>空格处理</h3><pre><code>空格，tab，换行：增加可读性</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code>1.不需要声明2.语法：$names3.=:赋值4.变量的释放：unset（$name）函数5.规则：区分大小写        字母下划线开头        不能数字开头        不能和关键字一样6.echo：输出7.可变变量     语法：$$名字//$test：可以输出他8.变量的引用赋值    语法：$a = 1000    $b = &amp;$a;    和C++一样：</code></pre><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><pre><code>PHP对类型比较弱由上下文决定1、bool：True = 1，False = 02、var_dump（）:类型函数3、int4、float5、string6、单引号里面的变量不会转型7、转义字符：一样8、双引号：也行9、用花括号包括：可以转型10、定界符：&lt;&lt;&lt;标识符；    例如：&lt;&lt;&lt;aaa    aaa；    里面什么都可以放11、数组12、对象13、NULL：空14、强制转换：（int）$b15、测试函数</code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><pre><code>1、定义和使用：define（常量名称，值）2、大写3、defined（）：测试是否含有某个常量4、一旦定义就不能重新定义或者取消5、bool int float string型：常量只能是6、预定义常量：php已经定义好的常量，不区分大小写，自己定义的常量区分7、两个下划线开头：__FILE__8、代码所在的位置 不同，值也不同：魔术常量9、八个常用的魔术常量：</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><pre><code>取反：-$a</code></pre><h3 id="字符串连接运算符"><a href="#字符串连接运算符" class="headerlink" title="字符串连接运算符"></a>字符串连接运算符</h3><pre><code>.:一个点$a.$b = $c.=：字符串连接再加等号echo输出bool值：true=1，false：什么都没有：用var_dump（）===：全等：值类相等!==:不全等</code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><pre><code>and &amp;&amp;or ||xor：异或not ！</code></pre><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><pre><code>1、一样</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>`“ ``”可以把系统命令放在里面执行`2、@：屏蔽表达式错误3、instanceof</code></pre><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre><code>1、if：一样2、if else3、if elseif else4、switch一样</code></pre><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><pre><code>1、while，do while ，for：一样2、break，continue，exit（）；</code></pre><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><h3 id="变量范围"><a href="#变量范围" class="headerlink" title="变量范围"></a>变量范围</h3><pre><code>1、局部2、全局：函数外，内部global3、静态：static</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>1、默认参数2、引用3、可改变参数的列表    func_get_args(索引);得到第几个参数    func_num_args():返回个数    func_get_arg4、可变函数    语法：$a = 'test'5、递归函数6、内置函数</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记</title>
      <link href="/2020/053054657.html"/>
      <url>/2020/053054657.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python学习笔记"><a href="#Python学习笔记" class="headerlink" title="Python学习笔记"></a>Python学习笔记</h1><h2 id="安装python和pycharm"><a href="#安装python和pycharm" class="headerlink" title="安装python和pycharm"></a>安装python和pycharm</h2><pre><code>自己百度多的是</code></pre><h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><pre><code>单行：#多行：''' '''中文编码声明注释：# -*- coding：utf-8 -*-(文件开始)                  #coding=编码</code></pre><h3 id="2-代码缩进"><a href="#2-代码缩进" class="headerlink" title="2.代码缩进"></a>2.代码缩进</h3><pre><code>缩进代替花括号</code></pre><h3 id="3-编码规范"><a href="#3-编码规范" class="headerlink" title="3.编码规范"></a>3.编码规范</h3><pre><code>1.import语句中导入一个模块：尽量避免一次导入多个模块2.每行不超过80个字符3.空行增加可读性4.运算符两参数之间两侧空格分隔5.避免在循环中使用+和+=累加字符串6.模块名短小，小写，可下划线分割7.包名短小，小写8.类名：首字母大写9.模块内部的类_加首字母大写10.函数，类的属性方法：小写和-分割11.使用单-  ：开头模块变量或函数是受保护的12.双--的开头实例变量或方法是私有的</code></pre><h3 id="4-保留字和标识符"><a href="#4-保留字和标识符" class="headerlink" title="4.保留字和标识符"></a>4.保留字和标识符</h3><pre><code>1.数字不开头2.严格区分大小写3.可以汉字但不要用4.下划线开头：单：保护变量   双：类的私有              双开头结尾：专用</code></pre><h3 id="5-六大基本数据类型"><a href="#5-六大基本数据类型" class="headerlink" title="5.六大基本数据类型"></a>5.六大基本数据类型</h3><h4 id="a-数字"><a href="#a-数字" class="headerlink" title="a.数字"></a>a.数字</h4><pre><code>round（0.1+0.2,小数点位数）：四舍五入函数</code></pre><h4 id="b-字符串"><a href="#b-字符串" class="headerlink" title="b.字符串"></a>b.字符串</h4><pre><code>1.''  '' ''  ''' ''':单行，多行2.转义字符</code></pre><h4 id="c-布尔类型"><a href="#c-布尔类型" class="headerlink" title="c.布尔类型"></a>c.布尔类型</h4><pre><code>1.True，False：首字母大写：True=1,False=0</code></pre><h3 id="6-数据类型转换"><a href="#6-数据类型转换" class="headerlink" title="6.数据类型转换"></a>6.数据类型转换</h3><pre><code>1.int（）2.float（）3.str（）4.hex（）：十六进制5.oct（）：八进制</code></pre><h3 id="7-基本输入输出"><a href="#7-基本输入输出" class="headerlink" title="7.基本输入输出"></a>7.基本输入输出</h3><pre><code>1.input（）：文本型：强制类型转换type（int（a））2.print（）：</code></pre><h3 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8.运算符"></a>8.运算符</h3><pre><code>1.算数运算符：/:浮点数  //:取整2.赋值运算符：+= -+ *= /= %=3.比较运算符：== != 4.逻辑运算符：and or not5.位运算:二进制计算：    位与&amp;：有0为0    位或|：有1为1    位取反~：0变1,1变0    位异或^:全0全1才为0    左移&lt;&lt;:左移舍去高位，最后补0    右移&gt;&gt;:右移高位舍去，最后补06.优先级：单目》算数》位运算》比较运算：括号改变</code></pre><h3 id="9-条件表达式"><a href="#9-条件表达式" class="headerlink" title="9.条件表达式"></a>9.条件表达式</h3><pre><code>c = a if a&gt;b else b:真左假右</code></pre><h3 id="10-流程控制"><a href="#10-流程控制" class="headerlink" title="10.流程控制"></a>10.流程控制</h3><h4 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h4><pre><code>顺序，选择，条件</code></pre><h4 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h4><pre><code>1.if 条件：  else：2.if 条件：   elif 条件：   else：3.</code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre><code>1.while 条件：    tab循环体2.for 迭代变量 in 对象：    tab 循环体    range（）：连续整数生成    range（起始：包括，结束：不包括，步长）3.没有do while4.嵌套  for 迭代变量 in 对象：      for 迭代变量 in 对象：</code></pre><h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><pre><code>break：continue：</code></pre><h4 id="pass空语句"><a href="#pass空语句" class="headerlink" title="pass空语句"></a>pass空语句</h4><pre><code>pass：占位</code></pre><h3 id="序列的运用"><a href="#序列的运用" class="headerlink" title="序列的运用"></a>序列的运用</h3><h4 id="索引（数组）"><a href="#索引（数组）" class="headerlink" title="索引（数组）"></a>索引（数组）</h4><pre><code>1.语法：string[0-n-1]2.可以是负数：从右向左计数-1开始：string[-2]3.切片：列表名【开始位置包括：结束位置不包括：步长默认1】4.序列相加：序列1 + 序列2：只能同类型：列表+列表，元组+元组5.序列乘法：序列*乘数:复制乘数遍6.检查某个元素是否在序列中：print（“科比”in nba）-&gt;True  not in:不在7.计算序列长度，最大值，最小值：len（） max（） min（）：数值类型</code></pre><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><pre><code>1.语法：[,,,,,]2.创建列表：list = 【，，，，，】  创建空列表：list = 【】  创建数值列表：数字组成的 list（range（2,21,2））  list（）：转换成列表  del():删除 3.访问列表元素  print  python【2】  python【1:3】 4.遍历列表     for item in 列表名：输出每个元素     for index，item in enumerate（列表名）：输出index，item        print（index+1，item） 5.添加元素     列表1.append（新元素）   列表1.insert（0，“新元素”）：指定位置   列表1.expend（添加的列表）：默认最后，添加一整个列表 6.修改元素：获取再赋值 7.删除 del li【2】：可以用负数        l1.remove（“值”） 8.列表统计计算     count（）：    语法：list.count(对象)    运用：统计出现次数    index（）    语法：同上    运用：第一次出现的位置    sum（）    语法：sum（列表[,start]）：可选值：统计结果加上    运用：total = sum（list，1000） 9.列表排序     1.sort（）    语法：list.sort(key = None,reverse = False)        key = str.lower:不区分大小写        reverse：默认降序   2.内置：sorted（）：原列表不改变顺序        语法：sorted(list,key = None,reverse = False)              reverse:默认升序 10.列表推导式  a.list1 = [random.randint(10，100)，for i in range（10）]   生成随机数列表   语法：list = [表达式 for var in range]   b.生成特定需求列表（后面是列表）   list = [表达式 for var in list]   c.提取列表中符合条件的组成新列表   语法：list = [表达式 for var in list if 条件] 11.二维列表使用     语法：list = [[],[],[],[]]</code></pre><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><h5 id="元组创建"><a href="#元组创建" class="headerlink" title="元组创建"></a>元组创建</h5><pre><code>truplename = (,,,)创建一个的时候再后面加上，号创建空元组：一样创建数值元组：一样</code></pre><h5 id="元组删除"><a href="#元组删除" class="headerlink" title="元组删除"></a>元组删除</h5><pre><code>del 元组名称</code></pre><h5 id="访问元组元素"><a href="#访问元组元素" class="headerlink" title="访问元组元素"></a>访问元组元素</h5><pre><code>print（）输出索引输出：元组名[1]切片输出：元组[1:3]for name in 元组：    print（name + “咖啡” end = “ ”）for index，item in enumerate（元组）</code></pre><h5 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h5><pre><code>1.不能对单个修改2.可以直接修改整个元组3.可以直接讲两个元组加起来4.单个元组要加，号</code></pre><h5 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h5><pre><code>1.随机生成：生成器对象，需要tuple转换2.访问过后生成器对象不存在了，转换为空</code></pre><h5 id="元组和列表的区别"><a href="#元组和列表的区别" class="headerlink" title="元组和列表的区别"></a>元组和列表的区别</h5><pre><code>1。元组不可变：不能添加删除，可以整体替换2，切片只能访问3，元组访问快4，可以作为字典键，列表不可以</code></pre><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><h5 id="键值对来组成"><a href="#键值对来组成" class="headerlink" title="键值对来组成"></a>键值对来组成</h5><pre><code>1.创建：word = {key1:值，，，，，}2.zip函数把列表转换成元组zip（list1，list2）返回zip对象，dict（）转换成字典3.dict{name：sign}：注意列表不能作为字典的键4.空的{}，dict（）5.dict = dict（name = '值'，，，，，）6.dict = dict.fromkeys(列表):只有名字的字典，值为none</code></pre><h5 id="删除字典"><a href="#删除字典" class="headerlink" title="删除字典"></a>删除字典</h5><pre><code>1.del 字典名2.字典名.clear()</code></pre><h5 id="键值对访问字典"><a href="#键值对访问字典" class="headerlink" title="键值对访问字典"></a>键值对访问字典</h5><pre><code>1.print：全部输出2.通过键访问值3.字典对象的get方法：    dict.get("key",[默认值])</code></pre><h5 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h5><pre><code>1.items方法：字典.items（）    for item in 字典.items（）：        print（item）2.也可以直接获得键和值 字典.key   字典.value</code></pre><h5 id="添加修改删除字典"><a href="#添加修改删除字典" class="headerlink" title="添加修改删除字典"></a>添加修改删除字典</h5><pre><code>1.添加:dict[key] = 值2.删除: del 字典[键]</code></pre><h5 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h5><pre><code>1.dict = {i:rangdom.randint(10,100) for i in range(1,5)}2.</code></pre><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><h5 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h5><pre><code>set集合：可变集合frozenset：不可变集合定义：不同对象的集合，不重复的元素字典和集合的区分：元素和键值对创建语法：{元素，，，，，，}集合：去重，顺序不定，不支持索引set（）：空集合set = set（）：也可以用来将其他的转换成集合</code></pre><h5 id="集合的添加和删除"><a href="#集合的添加和删除" class="headerlink" title="集合的添加和删除"></a>集合的添加和删除</h5><pre><code>集合名.add(不能是可迭代对象)集合.remove（删除元素）：一个集合.pop（无）：随机，返回删除的元素集合.clear():all</code></pre><h5 id="集合的交并补差"><a href="#集合的交并补差" class="headerlink" title="集合的交并补差"></a>集合的交并补差</h5><pre><code>&amp;：交|：并-：差</code></pre><h4 id="字符串编码转换"><a href="#字符串编码转换" class="headerlink" title="字符串编码转换"></a>字符串编码转换</h4><h5 id="encode-编码"><a href="#encode-编码" class="headerlink" title="encode:编码"></a>encode:编码</h5><pre><code>语法：str = str1.encode（GBK）:不会修改原字符串</code></pre><h5 id="decode：解码"><a href="#decode：解码" class="headerlink" title="decode：解码"></a>decode：解码</h5><pre><code>语法：str = str1.decode(GBK):什么编码什么解</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h5><pre><code>语法：+，不能把字符串和数值加起</code></pre><h5 id="计算长度"><a href="#计算长度" class="headerlink" title="计算长度"></a>计算长度</h5><pre><code>语法：len（字符串）：字符个数，不管中英文</code></pre><h5 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h5><pre><code>切片：string[stsrt:end:step]</code></pre><h5 id="分割合并字符串"><a href="#分割合并字符串" class="headerlink" title="分割合并字符串"></a>分割合并字符串</h5><pre><code>listname = str.split(分割符，分割次数)合并:语法：str = str.join(可迭代变量)  str = "@".join(list1)</code></pre><h5 id="检索字符串"><a href="#检索字符串" class="headerlink" title="检索字符串"></a>检索字符串</h5><pre><code>str.count(字符串，start，end):出现次数find（~）：是否存在，返回首次位置index（）：是否包含，不存在输出异常，返回第一次出现的位置starswith：以什么开始endswith：以什么结束</code></pre><h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><pre><code>lower（）:小写upper（）：大写</code></pre><h5 id="去除字符串的空格和特殊字符"><a href="#去除字符串的空格和特殊字符" class="headerlink" title="去除字符串的空格和特殊字符"></a>去除字符串的空格和特殊字符</h5><pre><code>1、strip：去除字符串两边空格。只会去除两侧，不会中间，可以指定去除啥2、lstrip：去除前面的字符3、rstrip：去除后面的</code></pre><h5 id="格式化字符串（后面来看）"><a href="#格式化字符串（后面来看）" class="headerlink" title="格式化字符串（后面来看）"></a>格式化字符串（后面来看）</h5><pre><code>%：-+0m.n格式化字符：%exp例如：%09d：9位数format：语法：str.format（参数）</code></pre><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><pre><code>1、匹配字符串的规则</code></pre><h5 id="行定位符"><a href="#行定位符" class="headerlink" title="行定位符"></a>行定位符</h5><pre><code>1、定位行：的开始和结束^:start $:end2、元字符：3、字符类：【aeiou】4、排除字符：^5、选择字符：|6、转义字符：\7、分组：（）</code></pre><h5 id="使用re模块匹配字符串"><a href="#使用re模块匹配字符串" class="headerlink" title="使用re模块匹配字符串"></a>使用re模块匹配字符串</h5><h6 id="匹配字符串"><a href="#匹配字符串" class="headerlink" title="匹配字符串"></a>匹配字符串</h6><pre><code>1、match（模式字符串，字符串，规则）：2、</code></pre><h3 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h3><h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><pre><code>语法：class 类名：（首字母大写）    '''帮助信息 '''    类体</code></pre><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><pre><code>语法：类名（可选参数）：没有init方法就不用参数</code></pre><h4 id="创建init（）方法"><a href="#创建init（）方法" class="headerlink" title="创建init（）方法"></a>创建<strong>init</strong>（）方法</h4><pre><code>意义：相当于构造方法：初始化，创建对象时自动使用语法：def __init__(self，，，):    print（）self:1.必须作为第一个参数2.相当于this指针3.写其他的也能输出，但不介意 构造方法：只能有一个</code></pre><h4 id="创建类的成员并访问"><a href="#创建类的成员并访问" class="headerlink" title="创建类的成员并访问"></a>创建类的成员并访问</h4><h5 id="创建实例方法并访问"><a href="#创建实例方法并访问" class="headerlink" title="创建实例方法并访问"></a>创建实例方法并访问</h5><pre><code>语法：def 名字（self（必须），参数列表）：      block方法名（参数列表）访问：对象.方法名（参数列表）默认值：参数后面加等号</code></pre><h5 id="创建数据成员并访问"><a href="#创建数据成员并访问" class="headerlink" title="创建数据成员并访问"></a>创建数据成员并访问</h5><h6 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h6><pre><code>定义：类中，方法体外语法：名字 = 值访问：init中：类名.类属性添加属性：类名.属性</code></pre><h6 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h6><pre><code>定义：方法中语法：def 名字（self）：            self.名字 =         self.名字 = 访问：self.名字   类外：对象.名字</code></pre><h5 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h5><pre><code>意义：语法：-：保护，类本身和子类可以访问，类外可以用对象访问      --：私有，类本身可以访问，对象不能访问，对象._类名+私有类型属性    --a--：系统</code></pre><h4 id="属性property"><a href="#属性property" class="headerlink" title="属性property"></a>属性property</h4><h5 id="创建用于计算的属性"><a href="#创建用于计算的属性" class="headerlink" title="创建用于计算的属性"></a>创建用于计算的属性</h5><pre><code>也就是装饰器：@property：转换成属性def 方法（self）：：可以修改block不能从新赋值</code></pre><h5 id="为属性添加安全保护机制"><a href="#为属性添加安全保护机制" class="headerlink" title="为属性添加安全保护机制"></a>为属性添加安全保护机制</h5><pre><code>装饰器：可以将私有属性设置为只读方法变装饰器可以更改：@show.setter：可以修改</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code>class 类名（基类，可以多个）：'''help '''   类体</code></pre><p>   注意：如果不指定基类，默认object</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2020/052813153.html"/>
      <url>/2020/052813153.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js</title>
      <link href="/2020/043017775.html"/>
      <url>/2020/043017775.html</url>
      
        <content type="html"><![CDATA[<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="一、helloWorld"><a href="#一、helloWorld" class="headerlink" title="一、helloWorld"></a>一、helloWorld</h2><pre><code>//从上到下执行// alert("这是我的第一行js代码");// 控制浏览器弹出一个警告框//在页面中输出一个内容// 可以在body中写一个内容// document.write("看我出不出来");// 向控制台输出一个内容// console.log("你猜我在那出来");// alert("这是我的第一行js代码");// document.write("看我出不出来");// console.log("你猜我在那出来");</code></pre><h2 id="二、js代码编写位置"><a href="#二、js代码编写位置" class="headerlink" title="二、js代码编写位置"></a>二、js代码编写位置</h2> <!-- 写到外部js文件中 --><pre><code>&lt;!-- 好处：在不同的页面中同时应用：也可以利用浏览器缓存机制          用于外部引入，就不能继续编写代码了          如果需要再新建一个script--&gt;</code></pre> <!-- 虽然可以写在标签属性中，但是他们属于结构与行为耦合，不方便维护 --><pre><code>&lt;!-- 可以将js代码编写到标签onclick属性中 --&gt;&lt;button onclick="alert('讨厌，dsafds');"&gt;点我一下&lt;/button&gt;&lt;!-- 可以将js下载超链接href属性中 --&gt;&lt;a href="javascript:alert('让你点你就点');"&gt;点&lt;/a&gt;&lt;!-- 占位符 --&gt;&lt;a href="javascript:;"&gt;点&lt;/a&gt;</code></pre><h2 id="三、基本语法"><a href="#三、基本语法" class="headerlink" title="三、基本语法"></a>三、基本语法</h2><pre><code>// js注释：单行    // 多行：/**/    /*    *   1、严格区分大小写    *   2、每一条语句分号结尾，不写自动添加：会消耗资源，会加错分号    *   3、会忽略多个空格和换行，利用空格，换行，格式化代码    */</code></pre><h2 id="四、字面量和变量"><a href="#四、字面量和变量" class="headerlink" title="四、字面量和变量"></a>四、字面量和变量</h2><pre><code> /*    *   字面量：都是不可改变的值，可直接使用但一般不会直接使用：比如：阿拉伯数字    *    *   变量：保存字面量    */    // 声明变量    // 在var关键字来声明变量    var a;    // 为变量赋值    a = 123;    var b = 567;    console.log(b);    console.log(a);</code></pre><h2 id="五、标识符"><a href="#五、标识符" class="headerlink" title="五、标识符"></a>五、标识符</h2><pre><code>// 所有可以自主命名的// 规则：字母、数字、下划线、$、// 不能数字开头// 不能是关键字或保留字// 驼峰命名：首字母小写，单词字母开头大写// utf-8保存</code></pre><h2 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h2><pre><code>// 数据类型：    // js：六种：String、Number、Boolean、Null、Undefined：未定义,Object:对象    // String：引号        // - 单双都可        // 不能嵌套：        //     // 转义字符    //  " \"    var str = "hello";</code></pre><h2 id="七、数值类型"><a href="#七、数值类型" class="headerlink" title="七、数值类型"></a>七、数值类型</h2><pre><code>// 所有数值都是Number类型：整数。浮点        // 可以使用运算符typeof 变量：检查变量类型        // 表示数字的最大值：Number.MAX_VALUE：表示的数字超过最大值:返回infinity（无穷）        // infinity:字面量        // typeof检查infinity：也会返回Number        // abc*bdc=NAN：不是数字        // Number.MIN_VALUE:0以上的最小值        // 浮点数：可能得到不精确的结果        // 布尔值：真假        // false,true逻辑判断    // Null:只有一个值    // 空的对象，typeof返回：object    // Undefined：未定义    // 当声明一个变量但未赋值时，就是这个</code></pre><h2 id="八、强制类型转换和运算符"><a href="#八、强制类型转换和运算符" class="headerlink" title="八、强制类型转换和运算符"></a>八、强制类型转换和运算符</h2><pre><code> // 强制类型转换：    // 主要是将其他的转成字符、数字、布尔    // 转换成String    // 方式1：调用被转换类型的ToString()方法:会有局限，            // null和Undefined没有ToString方法            // XXX.tostring()    // var a = 123;    // var b = a.toString();    // a = a.toString();    // 方式二：调用String函数，并将转换数据做参数:没局限            // 对于Number、Boolean就是调用ToString            // 另外两个直接转换成它的值null，undefined    // var a = 123;    // a = String(a);     // 强制转换成Number    // 方式1：使用Number()函数:有局限    //      字符串转数字：直接转成数字    //          非数字：NAN    //      空格：0    //      布尔转数字:0,1    //      Null转数字：0    //      Undefined：NAN    // 方式二：用于字符串：parseInt()：字符串中有效整数内容去出来然后转换成Number    //                    123dpf：123    // parseFloat()：整数+小数:132.332dsaf-&gt;132.332    // 如果对非字符：先转换成String再转成数字  // 16进制：0x123-&gt;123      // 8进制：0开头      // 2进制：0b开头：不是所有浏览器都支持      // parseIn两个参数：第二个指定进制parseIn(a,10)     // Boolean()；    // 除了0和NAN其余都是true    // 字符串：除了空串：其余都是true    // Null:false    // Undefined:false    // 对象：true      typeof就是运算符：获得值得类型是字符串    算数运算符：5    +：转换成数字计算：NAN+1=NAN：任何值：都是NAN     字符串：连接     还可声明时候连接起来换行写     任何值和字符串做加法都会先转成字符串：再连接     利用这一特点将：+""转换成字符    -：除了和字符串相加：其他都是转换成Number    -*/：都是转换成数字    可以用-0 *1 /1来转换成Number    %：     自增自减：一样一样     与运算：两个值都为true。返回后面的           两个值有false：返回前面那的false           第一个true：返回第二个值           如果第一个false：直接false、     或||：一样     非！：一样</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css字体和背景</title>
      <link href="/2020/043011637.html"/>
      <url>/2020/043011637.html</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-字体和背景"><a href="#CSS-字体和背景" class="headerlink" title="CSS-字体和背景"></a>CSS-字体和背景</h1><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code>    color: 颜色        font-size:字体大小        em：相当于当前元素的font-size        rm：相对于根元素的font-size        font-family：字体族            -serif：            -sans-size            -monospace；等宽                -指定字体类别                -可以设置多个：从第一个开始</code></pre><h2 id="图标字体"><a href="#图标字体" class="headerlink" title="图标字体"></a>图标字体</h2><pre><code>    用法：        - &lt;i class = "fas fa-bell"&gt;&lt;/i&gt;        后面fa-bell为图标名字；可以改颜色，大小，            -style=""里面设置  其他用法：    通过实体使用图标字体：&amp;#x图标的编码                        class = fas x        &lt;i class = "fas fa-bell"&gt;&lt;/i&gt;</code></pre><h2 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h2><h2 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h2><pre><code>行高：line.height        字体框：就是字体存在格子：设置font-size就是设置字体框大小        行高会在字体框的上下平均分配        设置行高和高一样，就是垂直居中        行间距等于行高-字体大小</code></pre><h2 id="字体的简写属性"><a href="#字体的简写属性" class="headerlink" title="字体的简写属性"></a>字体的简写属性</h2><pre><code>    font:设置所有属性                语法：字体大小/行高，字体族：必须写，最后两个                行高可以省略不写，默认值：            font-weight：字重：加粗                -可选值：                    -normal                    -bold            font-size：                -italic：斜体                -normal            font：时会覆盖上面的设置</code></pre><h2 id="文本的水平和垂直对齐"><a href="#文本的水平和垂直对齐" class="headerlink" title="文本的水平和垂直对齐"></a>文本的水平和垂直对齐</h2><pre><code>    text-align:文本的水平对齐                -可选值                   -left                   -right                   -center                   -justify:两端对齐            vertical:垂直对齐                -baseline:基线对齐                -top:顶部对齐                -bottom                -middle</code></pre><h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><pre><code>    text-decortion:        -none        -underline        -line-throught        -overline    white-space:设置空白处理        -normal        -nowrap:不换行        -pre：保留换行        -    text-overflow    overflow：        -elispsis：设置溢出省略号</code></pre><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><pre><code>设置背景图片            -可以同时设置背景图片和背景颜色            -如果背景图片大于元素：一部分无法显示            -如果背景图小：平铺            background-repead：用来设置背景重复方式                repead：默认值:xy方向重复                repead-x：                repead-y：                no-repead：不重复            background-position:设置背景图片的位置                -top，left，right，bottom，center九宫格            background-clip:设置边框范围                -border-box:默认背景出现在边框下面                -padding-box：背景不会出现在边框下面                -content-box：只出现在内容区            background-origin：背景图偏移位置                -padding-box：内边距上                -content-box：背景图片的偏移量从内容区计算                -border-box：边框上开始计算            background-size：设置背景图片大小                -两个值：只写一个自动                --cover：图片比例不变：铺满元素                -contain：比例不变，完整显示            background-attachment：设置图片移动                -srcoll：随元素移动                -fixed：不会随元素移动            注意：                -：size必须卸载position构面并用/隔开                -：origin要在clip的前面</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS-定位</title>
      <link href="/2020/043013442.html"/>
      <url>/2020/043013442.html</url>
      
        <content type="html"><![CDATA[<h1 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h1><h2 id="一、定位简介"><a href="#一、定位简介" class="headerlink" title="一、定位简介"></a>一、定位简介</h2><pre><code>定位：            -更加高级的布局手段            -通过定位可以将元素任意定位            -position属性设置定位                -可选值                    -static：元素静止：                    relative：开启相对定位：参照元素在文档流中的位置                    fixed：固定定位                    absolute：绝对定位                    sticky：粘滞定位            -相对定位：当元素的position属性值设定为relative                -不设置偏移量不会发生任何变化                -提升层级                -不会脱离文档流                -不改变属性            -偏移量：offset                -相当于margin这些                    -top                    -bottom                        -通常使用一个                    -left                    -right                        -通常使用一个</code></pre><h2 id="二、绝对定位"><a href="#二、绝对定位" class="headerlink" title="二、绝对定位"></a>二、绝对定位</h2><pre><code>绝对定位：positin：absolute                -绝对定位的特点                    -开启绝对定位后：如果不设置偏移量,元素位置不会发生变化                    -开启绝对定位后会从文档流中脱离                    -绝对定位会改变元素的性质：行内变成块，块的块高被内容撑开                    -会使元素提升一个层级                    -绝对定位元素相对于其包含块惊进行定位            包含块（containing block）                -正常：离当前元素最近的祖先元素                divdivdivdiv                divspanememspandiv：em的是div                -绝对定位的包含块：就是离他最近的开启了定位的祖先元素                    -如果都没有开启定位则：相对于根元素html：初始包含块</code></pre><h2 id="三、固定定位"><a href="#三、固定定位" class="headerlink" title="三、固定定位"></a>三、固定定位</h2><pre><code>固定定位：                -position：fixed                -也是一种绝对定位，大部分和绝对定位一样                -唯一不同：固定定位永远参照于浏览器的视口定位                -固定定位的元素不会随网页的滚动而移动</code></pre><h2 id="四、粘滞定位"><a href="#四、粘滞定位" class="headerlink" title="四、粘滞定位"></a>四、粘滞定位</h2><pre><code>粘滞定位                   -position：sticky                  - 和相对定位基本一样                  -在某一位置可以固定</code></pre><h2 id="五、绝对固定定位"><a href="#五、绝对固定定位" class="headerlink" title="五、绝对固定定位"></a>五、绝对固定定位</h2><pre><code>当我们开启绝对定位后                -水平方向布局等式需要加上left，fight两个值                    -当发生过度约束，9个值都没有auto，自动调整right满足                    -如果有auto调auto            可设置auto的值                -margin width left right            因为：left，right的值默认auto                等式 不满足，默认调整right，left            垂直方向布局的等式也必须要满足：</code></pre><h2 id="六、元素层级"><a href="#六、元素层级" class="headerlink" title="六、元素层级"></a>六、元素层级</h2><pre><code>z-index:设置层级                -值越大层级越高                -不写优先靠下的                -祖先元素的层级再高也不会盖住后代</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS—布局笔记</title>
      <link href="/2020/043011415.html"/>
      <url>/2020/043011415.html</url>
      
        <content type="html"><![CDATA[<h1 id="css布局"><a href="#css布局" class="headerlink" title="css布局"></a>css布局</h1><h2 id="一、文档流"><a href="#一、文档流" class="headerlink" title="一、文档流"></a>一、文档流</h2><pre><code>文档流（normal flow）            -网页是层叠的            -通过css可以给每一层设置样式            -用户只能看到最顶上一层            -这些层中最低下一层称为文档流            -我们所创建的元素默认都是在文档流中进行排列            -对于我们元素有两个状态                -在文档流中                -脱离文档流中            在文档流中有何特点                -块元素                    -块元素独占一行                    -默认宽度：父元素撑满                    -默认高度：内容撑满                -行内元素                    -不会独占一行                    -只占自身大小                    -一行中不能容纳所有：换行                    -行内元素的默认宽度：内容撑开</code></pre><h2 id="二、盒子模型"><a href="#二、盒子模型" class="headerlink" title="二、盒子模型"></a>二、盒子模型</h2><pre><code>    盒子模型        -box model        怎么摆放元素：            -css中将页面中的元素设置成了一个矩形盒子            -设置为矩形的盒子：布局就是摆放盒子            -怎么设置大小和位置：                -组成:                    -内容区（content）                    -边框（bonder）                    -内边距（padding）：内容区和边框的距离                    -外边距（margin）：决定位置；两个盒子间的距离</code></pre><h2 id="三、盒子模型-边框"><a href="#三、盒子模型-边框" class="headerlink" title="三、盒子模型-边框"></a>三、盒子模型-边框</h2><pre><code>    边框                -boder-width:默认值3px                    -四个值：顺时针                    -三个：左等于右                    -两个值：上下，左右                    -boder-top-width                        -top，right，left，bottom，  以下都有：                -boder-color：边框颜色                    -如果不写：默认指定color值                -boder-style：边框样式                    -soild： 实线                    -dotted：点状虚线                    -dashed：虚线                    -double：双线                    -不可不写：默认值是none                     boder简写形式：同时设定，没有顺序要求                    border: 10px orange solid;</code></pre><h2 id="四、盒子模型-内边距"><a href="#四、盒子模型-内边距" class="headerlink" title="四、盒子模型-内边距"></a>四、盒子模型-内边距</h2><pre><code>  内边距（padding）              -内容区和边框间的距离              -四个方向都有                  padding-top          -************************会影响到盒子的大小              -背景颜色会延伸到内边距上          盒子大小可见框：边框+内容+内边距</code></pre><h2 id="五、盒子模型-外边距"><a href="#五、盒子模型-外边距" class="headerlink" title="五、盒子模型-外边距"></a>五、盒子模型-外边距</h2><pre><code>   外边距（margin）            -不会影响可见框大小            -会影响盒子位置            -有四个方向        元素在页面中是按自左向右的顺序排列            -左上：会移动元素自身            -下右：移别人        可以设置负值：像相反方向移动        简写：margin：四个外边距        margin：影响盒子实际大小       </code></pre><h2 id="六、水平方向的布局"><a href="#六、水平方向的布局" class="headerlink" title="六、水平方向的布局"></a>六、水平方向的布局</h2><pre><code>    水平方向的布局：            -元素在其父元素中的水平布局               margin-left               border-left               padding-left               width               padding-right               border-right               margin-right            -一个元素在其父元素中必须满足：                从左到右加起来：外边距+内边距+内容+右部分=父元素内容区的宽度            不成立：过度约束：自动调整                -调整情况                    -如果这七个值中没有auto的情况：会调整margin-right满足            三个可以设置为auto；                -width                -margin-left                -margin-right                调整auto的值            水平居中：               实例：                  width：                  margin：auto</code></pre><h2 id="七、垂直方向的布局"><a href="#七、垂直方向的布局" class="headerlink" title="七、垂直方向的布局"></a>七、垂直方向的布局</h2><pre><code>      子元素大于父元素：撑破父元素：溢出        子元素在内容区中排列：            用overflow：设置处理溢出                -visable:显示溢出                -hidden：隐藏溢出                -scroll:生成滚动条，来查看完整的内容                -auto：根据需要生成滚动条            overflow-x：水平方向            overflow-y：垂直方向     </code></pre><h2 id="八、盒子模型外边距的折叠"><a href="#八、盒子模型外边距的折叠" class="headerlink" title="八、盒子模型外边距的折叠"></a>八、盒子模型外边距的折叠</h2><pre><code>    外边距的重叠：        -相邻的垂直外边距重叠：        -兄弟元素            -两者之间取较大值，两者都是正值            -一正一负：和            -两个负：两者取绝对值较大的        -兄弟元素之间外边距的重叠对于开发有利：不需要处理        -父子元素            -父子元素间的相邻外边距：子元素会传递给父元素            -父子外边距重叠会影响页面布局：必须处理       </code></pre><h2 id="九、行内元素的盒模型"><a href="#九、行内元素的盒模型" class="headerlink" title="九、行内元素的盒模型"></a>九、行内元素的盒模型</h2><pre><code>      行内元素            -display：元素显示模式                -可选值：                    -inline：设置为行内                    -block：设置为块元素                    -inline-block:行内块元素                        -既可以设置宽高，又不会独占一行:有缺点：想文字一样有间隔                    -table：设置为表格                    -none：不在页面中显示        visibility：设置显示状态              -visible：正常显示              -hidden：隐藏：占位置,none不占    </code></pre><h2 id="十、浏览器的默认样式"><a href="#十、浏览器的默认样式" class="headerlink" title="十、浏览器的默认样式"></a>十、浏览器的默认样式</h2><pre><code> 两个文件：normal，resert</code></pre><h2 id="十一、盒子大小"><a href="#十一、盒子大小" class="headerlink" title="十一、盒子大小"></a>十一、盒子大小</h2><pre><code>     默认情况下：可见框大小：内容+内边距+边框                box-sizing：设置盒子计算方式                    -可选值：                        content-box：高度和宽度设置内容区大小                        border-box：宽度高度设置盒子可见框大小                            三个加起来的大小</code></pre><h2 id="十二、圆角和轮廓"><a href="#十二、圆角和轮廓" class="headerlink" title="十二、圆角和轮廓"></a>十二、圆角和轮廓</h2><pre><code>  outline用来设置轮廓线            -轮廓不会影响可见框的大小，border会影响            -设置鼠标移入    box-shadow：用来设置元素的阴影效果：不会影响可见框大小            -默认和盒子一样大            -需要设置偏移量：默认偏移量是0            -第一个：左侧偏移值：水平位置            -第二个：右侧偏移值：垂直位置            -第三个：阴影模糊半径            -第四个：颜色            -可以设置负值           border-radius: ;        -设置圆角            -值为圆角半径            -指定四个角：顺时针：四个值            -三个值:对角一样            -两个：            -一个            -百分数：50%：圆形      </code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS笔记</title>
      <link href="/2020/043085.html"/>
      <url>/2020/043085.html</url>
      
        <content type="html"><![CDATA[<h1 id="css笔记"><a href="#css笔记" class="headerlink" title="css笔记"></a>css笔记</h1><h2 id="一、css3介绍"><a href="#一、css3介绍" class="headerlink" title="一、css3介绍"></a>一、css3介绍</h2><pre><code>    网页分成三个部分：        结构：html        表现：css        行为：js    css：        -层叠样式表：页面实际上是多层结构        -设置网页元素样式     -第一种方式（内联样式，行内样式）        -在便签内部通过style来设置元素样式，属性只能在开始标签写        -多以写多个        -font-size:字体大小</code></pre><h2 id="二、编写位置"><a href="#二、编写位置" class="headerlink" title="二、编写位置"></a>二、编写位置</h2><pre><code>    内联样式只能对一个标签产生影响        -当样式发生变化需要一个一个改    注意:开发时绝对不要用内联样式     第三种方式:外部样式(最佳实践)        -可以将css样式编写到一个外部css文件中        -然后通过link标签来引用外部文件,这样意味着只要想用样式网页都可以进行引用            -href:路径     -将样式编写到css文件中可以使用到浏览器的缓存机制从而加快网页加载速度</code></pre><h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><pre><code>    style标签内部不属于html    css基本语法:        -p:选择器:选择元素        {}:声明块:指定要为元素设置的样式;结尾为一个            -一个样式名对应样式值:用:连接</code></pre><h2 id="四、常用选择器"><a href="#四、常用选择器" class="headerlink" title="四、常用选择器"></a>四、常用选择器</h2><pre><code>    将所有的段落设置为红色(字体)        元素选择器            -标签名            h{}        id选择器:根据元素id属性值选中一个元素            -#id属性值{}            -设置两个id也可以但是不能这么做        列子:        class:是一个标签属性,和id类似,可以重复使用            -可以通过class分组            -.为class属性            -可以同时为一个元素指定多个class        通配选择器            -所有元素            语法:*</code></pre><h2 id="五、复合选择器"><a href="#五、复合选择器" class="headerlink" title="五、复合选择器"></a>五、复合选择器</h2><pre><code>  交集选择器:选中同时满足多个条件              -作用:同时选中多个元素              -选择器1.选择器2{}          注意:如果有元素选择器,那么必须元素选择器开头              选择器分组(并集选择器)        -作用:选择多个选择器对应的元素        -语法:选择器1,选择器2{}             #b1.p1,h1,span:选择id加元素          </code></pre><h2 id="六、关系选择器"><a href="#六、关系选择器" class="headerlink" title="六、关系选择器"></a>六、关系选择器</h2><pre><code>  为div直接包含的span这只一个字体颜色红色        （为div直接包含的span设置一个字体颜色）        ******子元素选择器            作用：选中指定父元素的指定子元素            语法：父元素&gt;子元素        ******后代元素选择器                作用：选中元素的后代元素                语法：祖先 后代                 兄弟元素选择器                -先择下一个兄弟                    -语法：前一个 + 下一个：紧挨着的，隔着一个也不行                -选择下边所有的兄弟：                    -语法：兄~弟        </code></pre><h2 id="七、属性选择器"><a href="#七、属性选择器" class="headerlink" title="七、属性选择器"></a>七、属性选择器</h2><pre><code>  属性选择器            -语法【属性名】:选择含有指定属性的元素            【属性名 = 属性值】            【属性名^=属性】：选择属性值以指定值开始的元素            【属性名$= 属性值】：结尾            【属性名*=属性值】：选择含有某值的元素          </code></pre><h2 id="八、伪类选择器"><a href="#八、伪类选择器" class="headerlink" title="八、伪类选择器"></a>八、伪类选择器</h2><pre><code>  伪类：不存在的类        -描述一个元素特殊状态的第一个子元素，被点击的元素，鼠标点击的元素        -伪类一般情况下：号开头            -:first-child第一个子元素            -:last-child最后一个子元素            -:nth-child（3）选中第3个子元素                特殊值：                    n：第n个，范围全部0-&amp;                    2n；偶数个                    2n+1：奇数                    odd：奇数                    even：偶数        -以上这些伪类都是根据所有子元素排序        ：first-of-type        ：last-of-type        ：nth-of-type           -只找相同类型    否定伪类：        ：not（）：            -将符合条件的元素去除          </code></pre><h2 id="九、a元素的伪类选择器"><a href="#九、a元素的伪类选择器" class="headerlink" title="九、a元素的伪类选择器"></a>九、a元素的伪类选择器</h2><pre><code>        link：没访问过的链接        visited:访问过            -隐私问题：visited只能改颜色             -只能超链接用上面两个        hover:鼠标移入        active：鼠标点击            </code></pre><h2 id="十、伪元素选择器"><a href="#十、伪元素选择器" class="headerlink" title="十、伪元素选择器"></a>十、伪元素选择器</h2><pre><code>  伪元素        -特殊不存在的元素（特殊位置）            伪元素：：开头            ::first—letter：第一个字母            ::first-line:第一行            ::selection:表示选中内容            ::before：起始位置            ::after：元素最后                -before/after结合content使用                -套框框           p::first-letter               {                   font-size: 50px;               }               p::first-line               {                   background-color: yellowgreen;               }               p::selection               {                   color: darkmagenta;               }               div::before               {                   content: 'abc';                   color: red;               }               div::after               {                   content: 'abc';                   color:green;               }</code></pre><h2 id="十一、样式继承"><a href="#十一、样式继承" class="headerlink" title="十一、样式继承"></a>十一、样式继承</h2><pre><code>    样式的继承：给一个标签设置的样式会继承给他的后代元素            -只发生在后代里            -为了方便开发，利用继承     注意：并不是所有的样式都会被继承            -比如：背景，布局相关的</code></pre><h2 id="十二、选择器的权重"><a href="#十二、选择器的权重" class="headerlink" title="十二、选择器的权重"></a>十二、选择器的权重</h2><pre><code>     选中同一个元素        -样式的冲突            -当我们通过不同的选择器选中相同的元素，并且为相同的样式设置不同的值，此时发生样式冲突        发生样式冲突:            优先级：                    内联样式                    id选择器                    类和伪类选择器                    元素选择器                    通配选择器：*                    继承:没有优先级        多个时；相加        分组选择器：单独计算，一个“，”一组            选择器的累加不会超过最大数量级：比如：类选择器不会大于id选择器        优先级一样时：自下而上        可以在某一个样式的后边添加：!important：最高优先级            -开发中慎用</code></pre><h2 id="十三、像素和百分比"><a href="#十三、像素和百分比" class="headerlink" title="十三、像素和百分比"></a>十三、像素和百分比</h2><pre><code>     长度单位：                像素                百分比：设置属性相当于父元素使用的百分比：这样父元素变，子元素也变                em:em是相对于元素的字体大小来计算的                    -1em = 1font-size                    -em会根据字体大小而改变                rem：rem相对于字体：root相对于根元素html的字体大小计算的</code></pre><h2 id="十四、RGB值"><a href="#十四、RGB值" class="headerlink" title="十四、RGB值"></a>十四、RGB值</h2><pre><code>    RGB:        -R        -G        —B    每一种颜色的范围0-255之间    也可以用百分数    语法：RGB（红，绿 ，蓝）    RGBA:        -A表示透明            -1表示完全不透明            0.5：半透明    十六进制的RGB值：        -语法:#红绿蓝        -浓度：00-ff        -如果颜色两位两位重复可以简写            #aabbcc--#abc    HSL,HSLA：        H：色相0-360        S：饱和度0-100%        L；亮度0-100%        都是写百分比的：必须写</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客已打包成apk</title>
      <link href="/2020/042835377.html"/>
      <url>/2020/042835377.html</url>
      
        <content type="html"><![CDATA[<p>博客已打包成apk<br>链接：<a href="https://pan.baidu.com/s/1NUq2-hf4oK2f3T1TgG6ckQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1NUq2-hf4oK2f3T1TgG6ckQ</a><br>提取码：reuw</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> VIP视频解析网站源码（放到coding就可用）</title>
      <link href="/2020/042718991.html"/>
      <url>/2020/042718991.html</url>
      
        <content type="html"><![CDATA[<h1 id="VIP视频解析网站（本地-coding可用）"><a href="#VIP视频解析网站（本地-coding可用）" class="headerlink" title="VIP视频解析网站（本地+coding可用）"></a>VIP视频解析网站（本地+coding可用）</h1><p>体验连接<a href="http://cszar4.coding-pages.com" target="_blank" rel="noopener">VIP视频解析</a><br>不建议手机观看，因为接口不是我自己的所以广告我拦不住</p><p><img src="https://s1.ax1x.com/2020/04/27/JfKBTI.png" alt="JfKBTI.png"></p><p>链接：<a href="https://pan.baidu.com/s/1H-en7yaGBvnsPZqHISPHlA" target="_blank" rel="noopener">https://pan.baidu.com/s/1H-en7yaGBvnsPZqHISPHlA</a><br>提取码：6h53</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VIP </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬取网页图片</title>
      <link href="/2020/042463275.html"/>
      <url>/2020/042463275.html</url>
      
        <content type="html"><![CDATA[<h1 id="python爬取网页图片源代码"><a href="#python爬取网页图片源代码" class="headerlink" title="python爬取网页图片源代码"></a>python爬取网页图片源代码</h1><pre><code>import requestsfrom bs4 import BeautifulSoupurl = "    "#发送源代码response = requests.get(url)#response=200:没毛病# print(response)#指定编码集response.encoding = 'utf-8'#获取源码# print(response.text)#把源代码交给beautifulmain_page = BeautifulSoup(response.text,"html.parser")#find：找# 1.find(标签，attrs={属性，值})：找一个# 2.find_all（标签，attrs={属性，值}）：找一堆alist = main_page.find("div",attrs={"class":"TypeList"}).find_all("a",attrs={"class":"TypeBigPics"})for a in alist:    href = a.get("href")    child_resp = requests.get(href) # 请求到子页面    #设置字符集    child_resp.encoding = "utf-8"    child_page = BeautifulSoup(child_resp.text,"html.parser") # 子页面提取内容    img = child_page.find("div",attrs={"id":"ArticleId8"}).find("img")    # print(img.get("src")) #拿到路径    title = child_page.find('div',attrs={"class":"ArticleTitle"}).text    #下载图片    f = open("%s.jpg" % title, mode='wb')    f.write(requests.get(img.get("src")).content)    print(1)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章编辑后台搭建</title>
      <link href="/2020/042423408.html"/>
      <url>/2020/042423408.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo博客后台搭建"><a href="#Hexo博客后台搭建" class="headerlink" title="Hexo博客后台搭建"></a>Hexo博客后台搭建</h1><iframe frameborder="no" bordered="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=28208212&amp;auto=1&amp;height=66"></iframe><h2 id="一、插件介绍"><a href="#一、插件介绍" class="headerlink" title="一、插件介绍"></a>一、插件介绍</h2><pre><code> hexo-admin 是一个Hexo博客引擎的管理用户界面插件。这个插件最初是作为本地编辑器设计的，在本地运行hexo使用hexo-admin编写文章，然后通过hexo g或hexo d（hexo g是本地渲染，hexo d是将渲染的静态页面发布到GitHub）将生成的静态页面发布到GitHub等静态服务器。如果你使用的是非静态托管服务器，比如自己买的主机搭建的hexo，那么一定要设置hexo-admin 的密码，否则谁都可以编辑你的文章。</code></pre><h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><p><img src="https://s1.ax1x.com/2020/04/24/JDZBTI.png" alt="JDZBTI.png"></p><p><img src="https://s1.ax1x.com/2020/04/24/JDeicD.png" alt="JDeicD.png"></p><h2 id="三、插件安装"><a href="#三、插件安装" class="headerlink" title="三、插件安装"></a>三、插件安装</h2><p>1.首先进入hexo创建的博客项目的根目录下，执行</p><pre><code>npm install --save hexo-admin</code></pre><p>2.运行下列命令启动hexo-admin </p><pre><code>hexo server -d</code></pre><p>3.打开<code>http://localhost:4000/admin/</code>就可以访问到hexo-admin管理页面了。</p><p><img src="https://s1.ax1x.com/2020/04/24/JDZBTI.png" alt="JDZBTI.png"></p><h2 id="四、密码保护"><a href="#四、密码保护" class="headerlink" title="四、密码保护"></a>四、密码保护</h2><p>打开<code>setting</code>，点击<code>Setup authentification here</code>输入用户名，密码，密钥，<code>设置完后下面会自动生成配置文件</code>，复制加在hexo根目录下的_config.yml中：</p><pre><code>admin:  username: myfavoritename  password_hash: be121740bf988b2225a313fa1f107ca1  secret: a secret something</code></pre><p><img src="https://s1.ax1x.com/2020/04/24/JDm9Vs.png" alt="JDm9Vs.png"></p><p>重启<code>hexo</code>，就可以看到登录页面了</p><h2 id="五、发布文章"><a href="#五、发布文章" class="headerlink" title="五、发布文章"></a>五、发布文章</h2><p><img src="https://s1.ax1x.com/2020/04/24/JDQDKK.png" alt="JDQDKK.png"><br>1、进入后台之后点击<code>Deploy</code>，里面的<code>Deploy</code>按钮是用来执行发布脚本的，所以我们先在博客<code>根目录</code>下新建<code>hexo-pubish.bat</code>(名字任意后缀<code>bat</code>)文件</p><p><img src="https://s1.ax1x.com/2020/04/24/JDmuZ9.png" alt="JDmuZ9.png"></p><p>然后填入如下代码</p><pre><code>hexo g -d</code></pre><p>然后在_config.yml中的admin下添加<code>deployCommand: 'hexo-pubish.bat'</code>(和之前创建的文件名相同)</p><pre><code>admin:  username: myfavoritename  password_hash: be121740bf988b2225a313fa1f107ca1  secret: a secret something  deployCommand: 'hexo-pubish.bat'</code></pre><p>设置发布执行的脚本，点击<code>Deploy</code>就会执行这个命令并提交到GitHub上。</p><p><img src="https://s1.ax1x.com/2020/04/24/JDnzAs.png" alt="JDnzAs.png"></p><p>开始提交：<br><img src="https://s1.ax1x.com/2020/04/24/JDKZM8.png" alt="JDKZM8.png"></p><p>成功如下：<br><img src="https://s1.ax1x.com/2020/04/24/JDKDRx.png" alt="JDKDRx.png"></p><h2 id="六、其他建议：添加一键本地运行"><a href="#六、其他建议：添加一键本地运行" class="headerlink" title="六、其他建议：添加一键本地运行"></a>六、其他建议：添加一键本地运行</h2><p>根目录下新建文件<code>hexo-s.bat</code><br><img src="https://s1.ax1x.com/2020/04/24/JDuljO.png" alt="JDuljO.png"></p><p>输入如下代码：</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s </code></pre><p>这样双击<code>hexo-s.bat</code>就可以直接本地查看了，很方便<br><img src="https://s1.ax1x.com/2020/04/24/JDuIrF.png" alt="JDuIrF.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python操作数据库</title>
      <link href="/2020/04233337.html"/>
      <url>/2020/04233337.html</url>
      
        <content type="html"><![CDATA[<h1 id="python操作数据库"><a href="#python操作数据库" class="headerlink" title="python操作数据库"></a>python操作数据库</h1><p><a href="https://imgchr.com/i/tVaisf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/28/tVaisf.jpg" alt="tVaisf.jpg"></a></p><h2 id="序章：mysql安装配置"><a href="#序章：mysql安装配置" class="headerlink" title="序章：mysql安装配置"></a>序章：mysql安装配置</h2><p><a href="https://www.jianshu.com/p/647a596cb251" target="_blank" rel="noopener">https://www.jianshu.com/p/647a596cb251</a></p><p><a href="https://www.cnblogs.com/winton-nfs/p/11524007.html" target="_blank" rel="noopener">https://www.cnblogs.com/winton-nfs/p/11524007.html</a></p><h2 id="第一章：为什么要数据库-gt-数据量大-方便管理"><a href="#第一章：为什么要数据库-gt-数据量大-方便管理" class="headerlink" title="第一章：为什么要数据库->数据量大,方便管理"></a>第一章：为什么要数据库-&gt;数据量大,方便管理</h2><pre><code>    sqlite:嵌入式数据库,数据库就是一个文件    mysql:开源</code></pre><h3 id="第一节-数据库编程接口"><a href="#第一节-数据库编程接口" class="headerlink" title="第一节:数据库编程接口"></a>第一节:数据库编程接口</h3><pre><code>    OB_API:数据库标准规范：PEP249:API规范</code></pre><h4 id="1-连接对象：connect-函数创建"><a href="#1-连接对象：connect-函数创建" class="headerlink" title="1.连接对象：connect()函数创建"></a>1.连接对象：connect()函数创建</h4><pre><code>    参数：        dsn：数据源名称        user：用户名        password：用户密码        host：主机名        datebase：数据库名</code></pre><h5 id="1-connect的常用方法"><a href="#1-connect的常用方法" class="headerlink" title="1.connect的常用方法"></a>1.connect的常用方法</h5><pre><code>    方法：    cursor():获取游标对象    commit():提交事务    rollback():回滚事务    close():关闭数据库连接</code></pre><h5 id="2-事务：转钱失败-回滚"><a href="#2-事务：转钱失败-回滚" class="headerlink" title="2.事务：转钱失败-回滚"></a>2.事务：转钱失败-回滚</h5><h4 id="2-游标对象cursor"><a href="#2-游标对象cursor" class="headerlink" title="2.游标对象cursor"></a>2.游标对象cursor</h4><pre><code>    方法：    callproc：调用存储过程    close：关闭    execute：执行数据库操作    executemany：批量执行    fechone：获取查询结果下一条    fechmany：获取指定数量    fechall：获取结构集的所有记录    nextset：跳至下一个结果集</code></pre><h4 id="3-先关闭cur再关闭connect"><a href="#3-先关闭cur再关闭connect" class="headerlink" title="3.先关闭cur再关闭connect"></a>3.先关闭cur再关闭connect</h4><h3 id="第二节：创建数据库文件"><a href="#第二节：创建数据库文件" class="headerlink" title="第二节：创建数据库文件"></a>第二节：创建数据库文件</h3><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><pre><code>#导入PyMySQL模块import pymysql#localhost是固定的host=localhost：不是连接名字#调用connect函数生产connection连接对象#不能换顺序，下面的参数顺序db = pymysql.connect(host = 'localhost',user= 'root',password = 'root',database = 'text')#调用cursor方法创建cursor对象cursor = db.cursor()#执行SQL语句cursor.execute('select version()')data = cursor.fetchone()print(data)#关闭连接cursor.close()db.close()</code></pre><h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><pre><code>#导入PyMySQL模块import pymysql#localhost是固定的host=localhost：不是连接名字#调用connect函数生产connection连接对象#不能换顺序，下面的参数顺序db = pymysql.connect(host = 'localhost',user= 'root',password = 'root',database = 'text')#调用cursor方法创建cursor对象cursor = db.cursor()cursor.execute('drop table if exists books')#执行SQL语句sql = """CREATE TABLE books(    id int(8) NOT NULL AUTO_INCREMENT,    name varchar(50) NOT NULL,    category varchar(50) NOT NULL,    price decimal(10,2) DEFAULT NULL,    publish_time date DEFAULT NULL,    PRIMARY KEY(id))ENGINE = MYISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;"""cursor.execute(sql)#关闭连接cursor.close()db.close()</code></pre><h4 id="操作数据表"><a href="#操作数据表" class="headerlink" title="操作数据表"></a>操作数据表</h4><pre><code>#导入PyMySQL模块import pymysql#localhost是固定的host=localhost：不是连接名字#调用connect函数生产connection连接对象#不能换顺序，下面的参数顺序db = pymysql.connect(host = 'localhost',user= 'root',password = 'root',database = 'text',charset = 'utf8')#调用cursor方法创建cursor对象cursor = db.cursor()#执行SQL语句data = [('lingisme9','python','79.89','2020-12-12'),('lingisme9','python','79.89','2020-12-12'),('lingisme9','python','79.89','2020-12-12'),('lingisme9','python','79.89','2020-12-12')]try:    sql = "insert into books(name,category,price,publish_time) values (%s,%s,%s,%s)"    cursor.executemany(sql,data)    db.commit()except:    db.rollback()#关闭连接cursor.close()db.close()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo框架matery主题+github搭建个人博客</title>
      <link href="/2020/042219999.html"/>
      <url>/2020/042219999.html</url>
      
        <content type="html"><![CDATA[<h1 id="hexo框架-github搭建个人博客"><a href="#hexo框架-github搭建个人博客" class="headerlink" title="hexo框架+github搭建个人博客"></a>hexo框架+github搭建个人博客</h1><p><img src="https://s1.ax1x.com/2020/04/22/JN7gcq.jpg" alt="坏蛋先生"></p><h2 id="一、hexo简介"><a href="#一、hexo简介" class="headerlink" title="一、hexo简介"></a>一、hexo简介</h2><p>1、Hexo 是一个快速、简洁且高效的博客框架。</p><p>2、官网入口及api：<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a></p><p>3、Hexo 是基于nodejs的框架</p><p>4、可以配置在很多地方：github、gitee、coding等</p><h2 id="二、nodejs安装配置"><a href="#二、nodejs安装配置" class="headerlink" title="二、nodejs安装配置"></a>二、nodejs安装配置</h2><p>1、Hexo是基于nodeJS环境的静态博客，需要用到nodejs中的npm安装（npm安装nodejs时自动安装）</p><p>2、下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a>推荐LTS (说明：LTS为长期支持版，Current为当前最新版)</p><p>3、安装步骤：下载好msi文件,一路next</p><p>4、验证安装:<code>win + r</code>输入 <code>cmd</code> 进入命令行窗口输入如下命令出现版本号安装成功：<br>    <code>$ node -v</code></p><h2 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h2><p>1、<code>你的用户名.github.io</code>   比如: 如果你的github用户名是<code>test</code>，那么你就新建<code>test.github.io的仓库</code>（必须是你的用户名）</p><p>2、新建<code>readerme</code>文件，什么都不用添加</p><p>3、访问：<code>你的用户名.github.io</code>（不出现404就行）</p><h2 id="三、git安装配置"><a href="#三、git安装配置" class="headerlink" title="三、git安装配置"></a>三、git安装配置</h2><p>1、<a href="https://git-scm.com/" target="_blank" rel="noopener">下载git</a></p><p>2、安装git（除图片这一步选第二个其他都next）<br>3、因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识，用户和邮箱为你github注册的账号和邮箱右键打开git-bash.exe<br><code>$ git config --global user.name "你的github用户名"</code><br><code>$ git config --global user.email "你注册github的邮箱"</code><br><img src="https://s1.ax1x.com/2020/04/22/JNHwx1.png" alt=""></p><p>4、为Github账户设置<code>SSH key</code>(ssh key是加密传输)<br>    首先检查是否生成了秘钥,如果没有生成，那么通过如下命令：<br>    <code>$ ssh-keygen -t rsa -C “你的github注册邮箱”</code>        </p><pre><code>1.是路径确认，直接按回车存默认路径即可2.直接回车键，这里我们不使用密码进行登录, 用密码太麻烦3.直接回车键</code></pre><p><img src="https://s1.ax1x.com/2020/04/22/JNHqiQ.png" alt=""></p><p>5、可以打开你的电脑<code>C:\Users\Administrator.ssh</code>里面找到，生成成功后，可以查看 <code>id_rsa.pub</code> 公钥文件</p><p>6、为github账号配置<code>ssh_key</code>：setting—&gt;SSH and GPG keys<br> <img src="https://s1.ax1x.com/2020/04/22/JNbKoD.png" alt=""></p><p>7、验证是否成功输入如下代码：<br>    <code>$ ssh -T git@github.com</code><br>正常情况下会出现(有警告可以不用管)：<br>    <code>Hi Your Name! You've successfully authenticated, but GitHub does not provide shell access.</code></p><h2 id="四、hexo安装"><a href="#四、hexo安装" class="headerlink" title="四、hexo安装"></a>四、hexo安装</h2><h3 id="这里介绍两种方法安装："><a href="#这里介绍两种方法安装：" class="headerlink" title="这里介绍两种方法安装："></a>这里介绍两种方法安装：</h3><h4 id="1、正常安装"><a href="#1、正常安装" class="headerlink" title="1、正常安装"></a>1、正常安装</h4><p>(1)右键打开<code>git bash here</code>输入如下代码：<br>    <code>$ npm install -g hexo-cli</code><br>如下成功：<br><img src="https://s1.ax1x.com/2020/04/22/JNqxET.png" alt=""><br>(2)查看版本信息输入如下代码：<br>    <code>$ hexo -v</code><br><img src="https://s1.ax1x.com/2020/04/22/JNLM2d.jpg" alt=""><br>(3)初始化hexo程序任意你想要保存博客文件的位置(推荐桌面,文件名随意)输入代码：<br>    <code>$ hexo init myblog</code></p><p>(4)进入<code>myblog</code>查看文件目录</p><p>** node_modules: 依赖包<br>** scaffolds：生成文章的一些模板<br>** source：用来存放你的文章<br>** themes：主题<br>** _config.yml: 博客的配置文件<br>** package.json：项目所需模块项目的配置信息</p><p><img src="https://s1.ax1x.com/2020/04/22/JNLYa8.jpg" alt=""><br>(5)打开hexo,本地查看，文件夹中会出现public的静态博客文件夹<br>a.输入如下命令生成public静态网页文件夹<br><code>$ hexo g</code></p><p>b.输入如下命令，本地查看（在浏览器中输入localhost：4000查看）<br><code>$ hexo s</code> </p><h4 id="2、hexo-init命令无法正常执行安装"><a href="#2、hexo-init命令无法正常执行安装" class="headerlink" title="2、hexo init命令无法正常执行安装"></a>2、<code>hexo init</code>命令无法正常执行安装</h4><p>(1)<a href="https://pan.baidu.com/s/1uaabyjR2ZdnmfjLu1QIBQg" target="_blank" rel="noopener">下载hexo基本文件 提取码：fn26</a></p><pre><code>_config.yml package.json scaffolds/ source/ themes/</code></pre><p>(2)安装依赖<br><code>$ npm install</code><br><code>$ npm install hexo-deployer-git --save  // 文章部署到 git 的模块</code></p><p>(3)输入如下命令生成public文件<br><code>$ hexo g</code></p><p>(4)输入如下命令本地查看<br><code>hexo s</code></p><h2 id="五、测试发布原生主题到github"><a href="#五、测试发布原生主题到github" class="headerlink" title="五、测试发布原生主题到github"></a>五、测试发布原生主题到github</h2><h3 id="1、修改你的根目录-config-yml-配置文件如下："><a href="#1、修改你的根目录-config-yml-配置文件如下：" class="headerlink" title="1、修改你的根目录 _config.yml 配置文件如下："></a>1、修改你的根目录 _config.yml 配置文件如下：</h3><pre><code># 注意是git开头的仓库地址# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.com:flyoob/flyoob.github.io.git  branch: master</code></pre><p>如何获取仓库地址<br><img src="https://s1.ax1x.com/2020/04/22/JUFycV.png" alt=""><br><img src="https://s1.ax1x.com/2020/04/22/JUFqBD.png" alt=""></p><h3 id="2、修改url：你的github用户名-github-io"><a href="#2、修改url：你的github用户名-github-io" class="headerlink" title="2、修改url：你的github用户名.github.io"></a>2、修改url：<code>你的github用户名.github.io</code></h3><p><img src="https://s1.ax1x.com/2020/04/22/JUFESx.png" alt="">也可以是你自己绑定的域名</p><h3 id="3、部署"><a href="#3、部署" class="headerlink" title="3、部署"></a>3、部署</h3><pre><code>hexo clean   // 清除缓存 网页正常情况下可以忽略此条命令hexo g       // 生成静态网页hexo d       // 开始部署</code></pre><h3 id="2、访问：你的用户名-github-io查看"><a href="#2、访问：你的用户名-github-io查看" class="headerlink" title="2、访问：你的用户名.github.io查看"></a>2、访问：<code>你的用户名.github.io</code>查看</h3><h2 id="六、下载matery主题"><a href="#六、下载matery主题" class="headerlink" title="六、下载matery主题"></a>六、下载matery主题</h2><h4 id="matery"><a href="#matery" class="headerlink" title="matery"></a><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">matery</a></h4><h2 id="七、配置matery主题"><a href="#七、配置matery主题" class="headerlink" title="七、配置matery主题"></a>七、配置matery主题</h2><h3 id="1-解压缩后，将hexo-theme-matery的文件夹复制到你-Hexo-的themes文件夹中即可。"><a href="#1-解压缩后，将hexo-theme-matery的文件夹复制到你-Hexo-的themes文件夹中即可。" class="headerlink" title="(1) 解压缩后，将hexo-theme-matery的文件夹复制到你 Hexo 的themes文件夹中即可。"></a>(1) 解压缩后，将<code>hexo-theme-matery</code>的文件夹复制到你 <code>Hexo</code> 的<code>themes</code>文件夹中即可。</h3><h3 id="2-切换主题"><a href="#2-切换主题" class="headerlink" title="(2) 切换主题"></a>(2) 切换主题</h3><pre><code>    修改 `Hexo `根目录下的` _config.yml `的 `theme `的值：`theme: hexo-theme-matery`</code></pre><h3 id="3-config-yml文件的其它修改建议"><a href="#3-config-yml文件的其它修改建议" class="headerlink" title="(3)_config.yml文件的其它修改建议:"></a>(3)<code>_config.yml</code>文件的其它修改建议:</h3><pre><code>请修改 _config.yml 的 url 的值为你的网站主 `URL（如：http://xxx.github.io）`。建议修改两个 `per_page `的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。如果你是中文用户，则建议修改 language 的值为` zh-CN`</code></pre><h3 id="4-新建分类-categories-页-注意页面上的分类不用你自己写，而是你在写文章时给文章写，matery会自己生成分类、标签"><a href="#4-新建分类-categories-页-注意页面上的分类不用你自己写，而是你在写文章时给文章写，matery会自己生成分类、标签" class="headerlink" title="(4)新建分类 categories 页(注意页面上的分类不用你自己写，而是你在写文章时给文章写，matery会自己生成分类、标签)"></a>(4)新建分类 <code>categories</code> 页(<code>注意页面上的分类不用你自己写，而是你在写文章时给文章写，matery会自己生成分类、标签</code>)</h3><p><code>categories</code>页是用来展示所有分类的页面，如果在你的博客 <code>source</code>目录下还没有 <code>categories/index.md</code>文件，那么你就需要新建一个，命令如下：<br><code>hexo new page "categories"</code><br>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>至少需要以下内容：</p><pre><code>---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---</code></pre><h3 id="5-新建标签-tags-页"><a href="#5-新建标签-tags-页" class="headerlink" title="(5)新建标签 tags 页"></a>(5)新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code>目录下还没有<code>tags/index.md</code>文件，那么你就需要新建一个，命令如下：<br><code>hexo new page "tags"</code><br>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre><code>---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---</code></pre><h3 id="6-新建关于我-about-页"><a href="#6-新建关于我-about-页" class="headerlink" title="(6)新建关于我 about 页"></a>(6)新建关于我 <code>about</code> 页</h3><p>about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 <code>source</code>目录下还没有<code>about/index.md</code>文件，那么你就需要新建一个，命令如下：<br><code>hexo new page "about"</code><br>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre><code>---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"---</code></pre><h3 id="7-新建友情连接-friends页（可选的）"><a href="#7-新建友情连接-friends页（可选的）" class="headerlink" title="(7)新建友情连接 friends页（可选的）"></a>(7)新建友情连接 <code>friends</code>页（可选的）</h3><p><code>friends</code> 页是用来展示友情连接信息的页面，如果在你的博客 source 目录下还没有<code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：<br><code>hexo new page "friends"</code><br>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>至少需要以下内容：</p><pre><code>---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"---</code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code>目录，在 <code>_data</code>目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre><code>[{    "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg",    "name": "码酱",    "introduction": "我不是大佬，只是在追寻大佬的脚步",    "url": "http://luokangyuan.com/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/4027734.jpeg",    "name": "闪烁之狐",    "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬",    "url": "https://blinkfox.github.io/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/avatar.jpg",    "name": "ja_rome",    "introduction": "平凡的脚步也可以走出伟大的行程",    "url": "ttps://me.csdn.net/jlh912008548",    "title": "前去学习"}]</code></pre><h3 id="8-代码高亮"><a href="#8-代码高亮" class="headerlink" title="(8)代码高亮"></a>(8)代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下：<br><code>npm i -S hexo-prism-plugin</code><br>然后，修改 <code>Hexo</code>根目录下 <code>_config.yml</code> 文件中<code>highlight.enable</code> 的值为 <code>false</code>，并新增<code>prism</code> 插件相关的配置，主要配置如下：</p><pre><code>highlight:  enable: falseprism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:</code></pre><h3 id="9-搜索"><a href="#9-搜索" class="headerlink" title="(9)搜索"></a>(9)搜索</h3><p>本主题中还使用到了 <code>hexo-generator-search</code> 的 <code>Hex</code>o 插件来做内容搜索，安装命令如下：<br><code>npm install hexo-generator-search --save</code><br>在 <code>Hexo</code>根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code>search:  path: search.xml  field: post</code></pre><h3 id="10-中文链接转拼音（可选的）"><a href="#10-中文链接转拼音（可选的）" class="headerlink" title="(10)中文链接转拼音（可选的）"></a>(10)中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用<code>hexo-permalink-pinyin Hexo</code>插件使在生成文章时生成中文拼音的永久链接。<br>安装命令如下：<br><code>npm i hexo-permalink-pinyin --save</code><br>在 <code>Hexo</code>根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre><code>permalink_pinyin:  enable: true  separator: '-' # default: '-'</code></pre><h3 id="11-文章字数统计插件（可选的）"><a href="#11-文章字数统计插件（可选的）" class="headerlink" title="(11)文章字数统计插件（可选的）"></a>(11)文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <code>hexo-wordcount</code>插件。<br>安装命令如下：<br><code>npm i --save hexo-wordcount</code><br>然后只需在本主题下的 <code>_config.yml</code>文件中，激活以下配置项即可：</p><pre><code>wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true</code></pre><h3 id="12-添加-RSS-订阅支持（可选的）"><a href="#12-添加-RSS-订阅支持（可选的）" class="headerlink" title="(12)添加 RSS 订阅支持（可选的）"></a>(12)添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <code>hexo-generator-feed</code> 的 <code>Hexo</code> 插件来做<code>RSS</code>，安装命令如下：<br><code>npm install hexo-generator-feed --save</code><br>在<code>Hexo</code>根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code>feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date</code></pre><p>执行<code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code>文件，说明你已经安装成功了。</p><h3 id="13-修改社交链接-主题中本来就有不用复制粘贴，源代码中修改即可"><a href="#13-修改社交链接-主题中本来就有不用复制粘贴，源代码中修改即可" class="headerlink" title="(13)修改社交链接(主题中本来就有不用复制粘贴，源代码中修改即可)"></a>(13)修改社交链接(<code>主题中本来就有不用复制粘贴，源代码中修改即可</code>)</h3><p>在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre><code>&lt;a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"&gt;    &lt;i class="fa fa-github"&gt;&lt;/i&gt;&lt;/a&gt;</code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在<code>Font Awesome</code>中搜索找到。以下是常用社交图标的标识，供你参考：</p><pre><code>    Facebook: fa-facebook    Twitter: fa-twitter    Google-plus: fa-google-plus    Linkedin: fa-linkedin    Tumblr: fa-tumblr    Medium: fa-medium    Slack: fa-slack    新浪微博: fa-weibo    微信: fa-wechat    QQ: fa-qq    注意: 本主题中使用的 Font Awesome 版本为 4.7.0。</code></pre><h3 id="14-修改打赏的二维码图片"><a href="#14-修改打赏的二维码图片" class="headerlink" title="(14)修改打赏的二维码图片"></a>(14)修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="15-配置音乐播放器（可选的）"><a href="#15-配置音乐播放器（可选的）" class="headerlink" title="(15)配置音乐播放器（可选的）"></a>(15)配置音乐播放器（可选的）</h3><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。</p><p>首先，在你的博客 <code>source</code> 目录下的 <code>_data</code> 目录（没有的话就新建一个）中新建 <code>musics.json</code> 文件，文件内容如下所示：</p><pre><code>[{    "name": "五月雨变奏电音",    "artist": "AnimeVibe",    "url": "http://xxx.com/music1.mp3",    "cover": "http://xxx.com/music-cover1.png"}, {    "name": "Take me hand",    "artist": "DAISHI DANCE,Cecile Corbel",    "url": "/medias/music/music2.mp3",    "cover": "/medias/music/cover2.png"}, {    "name": "Shape of You",    "artist": "J.Fla",    "url": "http://xxx.com/music3.mp3",    "cover": "http://xxx.com/music-cover3.png"}]</code></pre><p>注：以上 <code>JSON</code>中的属性：<code>name、artist、url、cover</code> 分别表示音乐的名称、作者、音乐文件地址、音乐封面。<br>然后，在主题的 <code>_config.yml</code>配置文件中激活配置即可：</p><pre><code># 是否在首页显示音乐.music:  enable: true  showTitle: false  title: 听听音乐  fixed: false # 是否开启吸底模式  autoplay: false # 是否自动播放  theme: '#42b983'  loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'list' # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: false # 列表默认折叠  listMaxHeight: # 列表最大高度</code></pre><h3 id="16-文章-Front-matter介绍-阅读文章时显示的信息"><a href="#16-文章-Front-matter介绍-阅读文章时显示的信息" class="headerlink" title="(16)文章 Front-matter介绍(阅读文章时显示的信息)"></a>(16)文章 <code>Front-matter</code>介绍(阅读文章时显示的信息)</h3><pre><code>---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h2 id="八、优化matery主题"><a href="#八、优化matery主题" class="headerlink" title="八、优化matery主题"></a>八、优化matery主题</h2><h3 id="1-修改主题颜色"><a href="#1-修改主题颜色" class="headerlink" title="(1)修改主题颜色"></a>(1)修改主题颜色</h3><p>在主题文件的<code>/source/css/matery.css</code>文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre><code>/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow {   /* 动态切换背景颜色. */}@keyframes rainbow {    /* 动态切换背景颜色. */}</code></pre><h3 id="2-修改-banner图和文章特色图-只要名字命名一样就行，图过大加载慢，图小不清晰图片批量压缩（密码：yvb5）"><a href="#2-修改-banner图和文章特色图-只要名字命名一样就行，图过大加载慢，图小不清晰图片批量压缩（密码：yvb5）" class="headerlink" title="(2)修改 banner图和文章特色图(只要名字命名一样就行，图过大加载慢，图小不清晰图片批量压缩（密码：yvb5）)"></a>(2)修改 <code>banner</code>图和文章特色图(只要名字命名一样就行，图过大加载慢，图小不清晰<a href="https://pan.baidu.com/s/1DlxWnHm5GLiopsJ21wkKyg" target="_blank" rel="noopener">图片批量压缩（密码：yvb5）</a>)</h3><p>你可以直接在 <code>/source/medias/banner</code>文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，</p><p><code>banner</code>切换的代码位置在 /<code>layout/_partial/bg-cover-content.ejs</code>文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><p><code>$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)');</code></p><p>在<code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。</p><h3 id="3-添加emoji表情支持（可选的）"><a href="#3-添加emoji表情支持（可选的）" class="headerlink" title="(3)添加emoji表情支持（可选的）"></a>(3)添加emoji表情支持（可选的）</h3><p>本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下：<br><code>npm install hexo-filter-github-emojis --save</code><br>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><pre><code>githubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:</code></pre><h3 id="4-给文章添加valine评论功能"><a href="#4-给文章添加valine评论功能" class="headerlink" title="(4)给文章添加valine评论功能"></a>(4)给文章添加valine评论功能</h3><p>进入主题文件的配置文件themes\matery_config.yml启用valine，其中需要设置Appid和appkey。此两项需要到<br><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">Leancloud官网</a><br><img src="https://s1.ax1x.com/2020/04/22/JNz2i6.jpg" alt=""><br>注册和身份验证通过后，新建应用，名字随意起。<br><img src="https://s1.ax1x.com/2020/04/22/JNzjSS.jpg" alt=""></p><p>再将信息填入</p><pre><code>valine:enable: trueappid: your app idappkey: your app keynotify: false # mail notifier , https://github.com/xCss/Valine/wikiverify: false # Verification codeplaceholder: just so soguest_info: nick,mail,linkpageSize: 10</code></pre><h3 id="5-修改头部幻灯片滤镜颜色和透明度"><a href="#5-修改头部幻灯片滤镜颜色和透明度" class="headerlink" title="(5)修改头部幻灯片滤镜颜色和透明度"></a>(5)修改头部幻灯片滤镜颜色和透明度</h3><p>打开matery.css，找到450行左右(建议直接注释掉，不好看)<br><img src="https://s1.ax1x.com/2020/04/22/JUSNmd.png" alt=""></p><h3 id="6-添加樱花飘落效果"><a href="#6-添加樱花飘落效果" class="headerlink" title="(6)添加樱花飘落效果"></a>(6)添加樱花飘落效果</h3><p>在<code>themes/matery/source/js</code>目录下新建<code>sakura.js</code>文件，打开这个网址<a href="https://cdn.jsdelivr.net/gh/baifeng66/cdn@1.1/source/js/sakura.js" target="_blank" rel="noopener">传送门</a>，将内容复制粘贴到sakura.js即可。</p><p>然后再themes/matery/layout/layout.ejs文件内添加下面的内容：</p><pre><code>&lt;script type="text/javascript"&gt;//只在桌面版网页启用特效var windowWidth = $(window).width();if (windowWidth &gt; 768) {    document.write('&lt;script type="text/javascript" src="/js/sakura.js"&gt;&lt;\/script&gt;');}&lt;/script&gt;</code></pre><h3 id="7-添加雪花飘落效果"><a href="#7-添加雪花飘落效果" class="headerlink" title="(7)添加雪花飘落效果"></a>(7)添加雪花飘落效果</h3><p>在<code>themes/matery/source/js</code>目录下新建<code>snow.js</code>文件，打开这个网址<a href="https://cdn.jsdelivr.net/gh/baifeng66/cdn@1.1/source/js/snow.js" target="_blank" rel="noopener">传送门</a>，将内容复制粘贴到<code>snow.js</code>即可。<br>然后再<code>themes/matery/layout/layout.ejs</code>文件内添加下面的内容：</p><pre><code>&lt;script src="/js/snow.js"&gt;&lt;/script&gt;</code></pre><h3 id="8-文章生成永久链接-提交github时会自动生成"><a href="#8-文章生成永久链接-提交github时会自动生成" class="headerlink" title="(8)文章生成永久链接(提交github时会自动生成)"></a>(8)文章生成永久链接(提交github时会自动生成)</h3><p>主题默认的文章链接配置是<br><code>permalink: :year/:month/:day/:title</code><br>这种生成的链接地址很长，文章版权的链接地址会出现一大串字符编码，一点也不好看。因此需要修改文章生成链接的格式。<br>首先再根目录下执行下面的命令：<br><code>npm install hexo-abbrlink --save</code><br>然后再根目录yml文件下添加如下配置：</p><pre><code>abbrlink:    alg: crc16   #算法： crc16(default) and crc32    rep: hex     #进制： dec(default) and hex: dec #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制</code></pre><p>然后再根目录yml文件下<code>permalink</code>的值修改为：<br><code>permalink: posts/:abbrlink.html  # 此处可以自己设置，也可以直接使用 :/abbrlink</code><br>生成完后，原md文件的Front-matter 内会增加abbrlink 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</p><h2 id="提交github（剧终）"><a href="#提交github（剧终）" class="headerlink" title="提交github（剧终）"></a>提交github（剧终）</h2><pre><code>hexo clean   // 清除缓存 网页正常情况下可以忽略此条命令hexo g       // 生成静态网页hexo d       // 开始部署</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记</title>
      <link href="/2020/042247896.html"/>
      <url>/2020/042247896.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html学习笔记</title>
      <link href="/2020/042250736.html"/>
      <url>/2020/042250736.html</url>
      
        <content type="html"><![CDATA[<h1 id="html学习笔记"><a href="#html学习笔记" class="headerlink" title="html学习笔记"></a>html学习笔记</h1><h2 id="一、实体"><a href="#一、实体" class="headerlink" title="一、实体"></a>一、实体</h2><pre><code>1.使用实体的原因：多个空格只认一个空格只认一个        2.在html中不能书写特殊符号：空格，大于小于        3.如果需要书写特殊符号那么就需要特殊符号：实体        4.实体的语法            &amp;实体的没名字                &amp;nbsp；：表示空格                &amp;gt；：大于号                &amp;lt：小于号                &amp;copy；：版权符号        5.怎样查询实体：w3school实体</code></pre><h2 id="二、meta标签"><a href="#二、meta标签" class="headerlink" title="二、meta标签"></a>二、meta标签</h2><pre><code>    1.meta主要用于表示元数据，元数据不给用户看    2.charset 指定网页字符集    3.name 指定数据名字    4.content 指定数据内容        keywords:表示网页关键字，可以设置多个关键字，用“，”隔开        description：网站描述会显示在搜索描述里面    5.title标签的内容：超链接上的标签显示  *********************将页面重定义到另一个网站</code></pre><h2 id="三、语义化标签"><a href="#三、语义化标签" class="headerlink" title="三、语义化标签"></a>三、语义化标签</h2><p>网页中html负责网页结构，<br>            在使用时应该关注语义而不是样式</p><pre><code>        标题标签            h1~h6            h1只有一个            一般情况下标题只用到h1~h3        块元素：在页面中独占一行block element            hgtoup:用来给标签分组           &lt;hgroup&gt;                    &lt;h1&gt;一级标题&lt;/h1&gt;                    &lt;h2&gt;二级标题&lt;/h2&gt;                 &lt;/hgroup&gt;        em标签：用于语音语调加重                  行内元素：不会独占一行:inline element            &lt;!-- strong :表示强调重要内容--&gt;            &lt;p&gt;你今天不需要&lt;strong&gt;完成作业&lt;/strong&gt;&lt;/p&gt;      blockquote:表示长引用，换行      鲁迅说：      &lt;blockquote&gt;          这句话我没说过      &lt;/blockquote&gt;      &lt;!-- 不换行：行标签 --&gt;      鲁迅说：      &lt;q&gt;          这句话我没说过      &lt;/q&gt;      &lt;!-- br --&gt;      &lt;br&gt;      这句话我没说过      &lt;!-- 乱码处理，点击utf-8 --&gt;    块元素 block element        --对页面进行布局，一块一块的    行内元素 inline element        --行内元素主要用来包裹文字        --一般情况下在块元素中放行内元素        --块元素中基本什么都能放        --p元素中不能放任何块元素    浏览器在解析网站时会修正不符合规范的内容    比如：        -标签写在外部        -p元素中嵌套了块元素        -根元素中出现了除了head，body以外的子元素    浏览器开发工具：element右键查看：内存中的代码存在 &lt;!--     布局标签（结构化语义）    header:头部    main:主体,一个页面只有一个    footer:尾部    nav:导航：一堆分类那块    aside：主体相关的不属于主体的内容    article：独立文章    section：独立区块：上面的标签都不能表示时    *div：没有语义，表示区块：目前来讲的主要布局元素    *span:行内元素,没有语义，主要用于选中文字 --&gt;</code></pre><h2 id="四、列表"><a href="#四、列表" class="headerlink" title="四、列表"></a>四、列表</h2><pre><code> &lt;!--     列表:list        -铅笔        -尺子        -橡皮    在html中也可以创建列表：        -有序列表        -无序列表        -定义列表        ul：无序列表            -使用li来表示列表项        ol：有序列表            -li        dl：定义序列            dt来表示定义内容            dd来解释说明        列表之间可以互相嵌套            ul中套ul --&gt;</code></pre><h2 id="五、超链接"><a href="#五、超链接" class="headerlink" title="五、超链接"></a>五、超链接</h2><pre><code>超链接：a标签：（行内标签）    -属性：href：指定跳转路径        -值可以是外部网站地址        -可以是内部页面地址：同一目录下就可以超链接a标签是行内标签，在a标签中可以嵌套除它自生外的任何元素</code></pre><h2 id="六、相对路径"><a href="#六、相对路径" class="headerlink" title="六、相对路径"></a>六、相对路径</h2><pre><code>    跳转服务器内部页面时要相对路径：       ./或../开头       可以省略       ./:表示当前文件所在目录            09.相对路径.html            在同一目录下可以不写       ../：上一级目录中查找       读当前，读下一级，读上一级;</code></pre><h2 id="七、超链接的其他应用"><a href="#七、超链接的其他应用" class="headerlink" title="七、超链接的其他应用"></a>七、超链接的其他应用</h2><pre><code> a标签的属性值：        target:指定超链接打开的位置:新标签            -_self 默认值:当前标签页            -_blank 新的页面中打开标签页 &lt;a href="#bottom"&gt;去底部&lt;/a&gt; &lt;a href="09.相对路径.html" target="_blank"&gt;超链接&lt;/a&gt;  回到顶部：        id属性:唯一不重复的            -每一个标签都可以添加id属性,唯一标识,同一个页面中不能相同出现id属性            -字母开头        可以跳转到指定位置:#标签 在开发中可以用：        -#去代表一个占位符会刷新页面        -javascript:;占位符,不会发生任何反应</code></pre><h2 id="八、图片标签"><a href="#八、图片标签" class="headerlink" title="八、图片标签"></a>八、图片标签</h2><pre><code>    图片标签:当前页面引入图片        img:自结束标签            属性                src：指定路径                img属于替换元素：img所引用的外部元素替换img                alt：图片属性,默认不会显示，无法加载时可能会显示                搜索引擎会按alt来识别图片                width：宽度                hight：高度                只修改一个：等比缩放                通常指定一个就行            注意：不建议修改图片大小                 移动端经常修改    图片的格式：        jpg:颜色多，不支持透明，不支持动图            -表示照片        gif:支持颜色少，支持简单透明，支持动图            -颜色单一的图片，动图        png:支持颜色丰富，支持复杂透明，不支持动图            -颜色丰富，复杂透明        webp:            谷歌新推出网页的图片格式            具备其他格式的所有有点，文件还小            效果一样用小的，效果不同用好的            兼容不好也可以复制图片代码直接等号后面       base64        -将图片用base64编码，这样可以将字符转换为字符，通过字符形式引入图片        -一般都是和网页一起加载的图片才会使用，不会出现延迟，加载速度快</code></pre><h2 id="九、内敛样式"><a href="#九、内敛样式" class="headerlink" title="九、内敛样式"></a>九、内敛样式</h2><pre><code>    iframe    内联框架：用于当前页面中引入别的网站        -src：网页路径        -frameborder：指定内联框架的边框：不好看            -会产生凹下去的外框，不好看                -1：打开                -0：关闭</code></pre><h2 id="十、音视频"><a href="#十、音视频" class="headerlink" title="十、音视频"></a>十、音视频</h2><pre><code>    audio:像页面中引入音频文件    属性：        -controls：是否允许用户控制        -autoplay：自动播放            -如果设置，打开页面时会自动播放，目前大部分浏览器不会自动播放            -先播放一次之后就可以自动播放了，IE可以        loop:循环播放    除了scr指定文件之外;还可以用scorce来指定文件        -指定多个文件，不会全部执行，找一个支持的    embed:老版本的播放，自动播放，第二次会变很小：指定宽高        -type：指定类型    video：引入视频文件    属性：        -autoplay        -loop        -音频通常用source，这样兼容性好 一般不用这种绝对路径的方法         allowFullScreen="true"：全屏         一般引入：和之前一样：</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> 网页开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-学生成绩管理系统</title>
      <link href="/2020/042013214.html"/>
      <url>/2020/042013214.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> C </tag>
            
            <tag> 软件开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C个人学习笔记</title>
      <link href="/2020/042012132.html"/>
      <url>/2020/042012132.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> C </tag>
            
            <tag> 软件开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-贪吃蛇</title>
      <link href="/2020/042013548.html"/>
      <url>/2020/042013548.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 软件开发 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站导航</title>
      <link href="/2020/042027176.html"/>
      <url>/2020/042027176.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VIP </tag>
            
            <tag> 资源 </tag>
            
            <tag> 网站 </tag>
            
            <tag> 工具 </tag>
            
            <tag> 破解 </tag>
            
            <tag> 素材库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件资源</title>
      <link href="/2020/042027176.html"/>
      <url>/2020/042027176.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
            <tag> 破解 </tag>
            
            <tag> 软件 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
